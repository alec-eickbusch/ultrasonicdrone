// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#ifndef PROTOBUF_mysqlx_5fcrud_2eproto__INCLUDED
#define PROTOBUF_mysqlx_5fcrud_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mysqlx_expr.pb.h"
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
namespace Mysqlx {
namespace Crud {
class Collection;
class CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class Column;
class ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class Delete;
class DeleteDefaultTypeInternal;
extern DeleteDefaultTypeInternal _Delete_default_instance_;
class Find;
class FindDefaultTypeInternal;
extern FindDefaultTypeInternal _Find_default_instance_;
class Insert;
class InsertDefaultTypeInternal;
extern InsertDefaultTypeInternal _Insert_default_instance_;
class Insert_TypedRow;
class Insert_TypedRowDefaultTypeInternal;
extern Insert_TypedRowDefaultTypeInternal _Insert_TypedRow_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class Order;
class OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class Projection;
class ProjectionDefaultTypeInternal;
extern ProjectionDefaultTypeInternal _Projection_default_instance_;
class Update;
class UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
class UpdateOperation;
class UpdateOperationDefaultTypeInternal;
extern UpdateOperationDefaultTypeInternal _UpdateOperation_default_instance_;
}  // namespace Crud
namespace Datatypes {
class Any;
class AnyDefaultTypeInternal;
extern AnyDefaultTypeInternal _Any_default_instance_;
class Array;
class ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_ObjectField;
class Object_ObjectFieldDefaultTypeInternal;
extern Object_ObjectFieldDefaultTypeInternal _Object_ObjectField_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class Scalar_Octets;
class Scalar_OctetsDefaultTypeInternal;
extern Scalar_OctetsDefaultTypeInternal _Scalar_Octets_default_instance_;
class Scalar_String;
class Scalar_StringDefaultTypeInternal;
extern Scalar_StringDefaultTypeInternal _Scalar_String_default_instance_;
}  // namespace Datatypes
namespace Expr {
class Array;
class ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class ColumnIdentifier;
class ColumnIdentifierDefaultTypeInternal;
extern ColumnIdentifierDefaultTypeInternal _ColumnIdentifier_default_instance_;
class DocumentPathItem;
class DocumentPathItemDefaultTypeInternal;
extern DocumentPathItemDefaultTypeInternal _DocumentPathItem_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class FunctionCall;
class FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_ObjectField;
class Object_ObjectFieldDefaultTypeInternal;
extern Object_ObjectFieldDefaultTypeInternal _Object_ObjectField_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
}  // namespace Expr
}  // namespace Mysqlx

namespace Mysqlx {
namespace Crud {

namespace protobuf_mysqlx_5fcrud_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mysqlx_5fcrud_2eproto

enum Order_Direction {
  Order_Direction_ASC = 1,
  Order_Direction_DESC = 2
};
bool Order_Direction_IsValid(int value);
const Order_Direction Order_Direction_Direction_MIN = Order_Direction_ASC;
const Order_Direction Order_Direction_Direction_MAX = Order_Direction_DESC;
const int Order_Direction_Direction_ARRAYSIZE = Order_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Order_Direction_descriptor();
inline const ::std::string& Order_Direction_Name(Order_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Order_Direction_descriptor(), value);
}
inline bool Order_Direction_Parse(
    const ::std::string& name, Order_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Order_Direction>(
    Order_Direction_descriptor(), name, value);
}
enum UpdateOperation_UpdateType {
  UpdateOperation_UpdateType_SET = 1,
  UpdateOperation_UpdateType_ITEM_REMOVE = 2,
  UpdateOperation_UpdateType_ITEM_SET = 3,
  UpdateOperation_UpdateType_ITEM_REPLACE = 4,
  UpdateOperation_UpdateType_ITEM_MERGE = 5,
  UpdateOperation_UpdateType_ARRAY_INSERT = 6,
  UpdateOperation_UpdateType_ARRAY_APPEND = 7
};
bool UpdateOperation_UpdateType_IsValid(int value);
const UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MIN = UpdateOperation_UpdateType_SET;
const UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MAX = UpdateOperation_UpdateType_ARRAY_APPEND;
const int UpdateOperation_UpdateType_UpdateType_ARRAYSIZE = UpdateOperation_UpdateType_UpdateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpdateOperation_UpdateType_descriptor();
inline const ::std::string& UpdateOperation_UpdateType_Name(UpdateOperation_UpdateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpdateOperation_UpdateType_descriptor(), value);
}
inline bool UpdateOperation_UpdateType_Parse(
    const ::std::string& name, UpdateOperation_UpdateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateOperation_UpdateType>(
    UpdateOperation_UpdateType_descriptor(), name, value);
}
enum DataModel {
  DOCUMENT = 1,
  TABLE = 2
};
bool DataModel_IsValid(int value);
const DataModel DataModel_MIN = DOCUMENT;
const DataModel DataModel_MAX = TABLE;
const int DataModel_ARRAYSIZE = DataModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataModel_descriptor();
inline const ::std::string& DataModel_Name(DataModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataModel_descriptor(), value);
}
inline bool DataModel_Parse(
    const ::std::string& name, DataModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataModel>(
    DataModel_descriptor(), name, value);
}
// ===================================================================

class Column : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Column) */ {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }

  void Swap(Column* other);

  // implements Message ----------------------------------------------

  inline Column* New() const PROTOBUF_FINAL { return New(NULL); }

  Column* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Column* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  int document_path_size() const;
  void clear_document_path();
  static const int kDocumentPathFieldNumber = 3;
  const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Column)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_alias();
  void clear_has_alias();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Projection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Projection) */ {
 public:
  Projection();
  virtual ~Projection();

  Projection(const Projection& from);

  inline Projection& operator=(const Projection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Projection& default_instance();

  static inline const Projection* internal_default_instance() {
    return reinterpret_cast<const Projection*>(
               &_Projection_default_instance_);
  }

  void Swap(Projection* other);

  // implements Message ----------------------------------------------

  inline Projection* New() const PROTOBUF_FINAL { return New(NULL); }

  Projection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Projection& from);
  void MergeFrom(const Projection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Projection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // required .Mysqlx.Expr.Expr source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::Mysqlx::Expr::Expr& source() const;
  ::Mysqlx::Expr::Expr* mutable_source();
  ::Mysqlx::Expr::Expr* release_source();
  void set_allocated_source(::Mysqlx::Expr::Expr* source);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Projection)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_alias();
  void clear_has_alias();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  ::Mysqlx::Expr::Expr* source_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Collection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Collection) */ {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Collection& default_instance();

  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }

  void Swap(Collection* other);

  // implements Message ----------------------------------------------

  inline Collection* New() const PROTOBUF_FINAL { return New(NULL); }

  Collection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Collection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string schema = 2;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 2;
  const ::std::string& schema() const;
  void set_schema(const ::std::string& value);
  #if LANG_CXX11
  void set_schema(::std::string&& value);
  #endif
  void set_schema(const char* value);
  void set_schema(const char* value, size_t size);
  ::std::string* mutable_schema();
  ::std::string* release_schema();
  void set_allocated_schema(::std::string* schema);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Collection)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_schema();
  void clear_has_schema();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr schema_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }

  void Swap(Limit* other);

  // implements Message ----------------------------------------------

  inline Limit* New() const PROTOBUF_FINAL { return New(NULL); }

  Limit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Limit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 row_count = 1;
  bool has_row_count() const;
  void clear_row_count();
  static const int kRowCountFieldNumber = 1;
  ::google::protobuf::uint64 row_count() const;
  void set_row_count(::google::protobuf::uint64 value);

  // optional uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Limit)
 private:
  void set_has_row_count();
  void clear_has_row_count();
  void set_has_offset();
  void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 row_count_;
  ::google::protobuf::uint64 offset_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Order : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Order) */ {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Order& default_instance();

  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }

  void Swap(Order* other);

  // implements Message ----------------------------------------------

  inline Order* New() const PROTOBUF_FINAL { return New(NULL); }

  Order* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Order* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Order_Direction Direction;
  static const Direction ASC =
    Order_Direction_ASC;
  static const Direction DESC =
    Order_Direction_DESC;
  static inline bool Direction_IsValid(int value) {
    return Order_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Order_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Order_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Order_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Order_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Order_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Order_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::Mysqlx::Expr::Expr& expr() const;
  ::Mysqlx::Expr::Expr* mutable_expr();
  ::Mysqlx::Expr::Expr* release_expr();
  void set_allocated_expr(::Mysqlx::Expr::Expr* expr);

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::Mysqlx::Crud::Order_Direction direction() const;
  void set_direction(::Mysqlx::Crud::Order_Direction value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Order)
 private:
  void set_has_expr();
  void clear_has_expr();
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Mysqlx::Expr::Expr* expr_;
  int direction_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.UpdateOperation) */ {
 public:
  UpdateOperation();
  virtual ~UpdateOperation();

  UpdateOperation(const UpdateOperation& from);

  inline UpdateOperation& operator=(const UpdateOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateOperation& default_instance();

  static inline const UpdateOperation* internal_default_instance() {
    return reinterpret_cast<const UpdateOperation*>(
               &_UpdateOperation_default_instance_);
  }

  void Swap(UpdateOperation* other);

  // implements Message ----------------------------------------------

  inline UpdateOperation* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateOperation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateOperation& from);
  void MergeFrom(const UpdateOperation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UpdateOperation_UpdateType UpdateType;
  static const UpdateType SET =
    UpdateOperation_UpdateType_SET;
  static const UpdateType ITEM_REMOVE =
    UpdateOperation_UpdateType_ITEM_REMOVE;
  static const UpdateType ITEM_SET =
    UpdateOperation_UpdateType_ITEM_SET;
  static const UpdateType ITEM_REPLACE =
    UpdateOperation_UpdateType_ITEM_REPLACE;
  static const UpdateType ITEM_MERGE =
    UpdateOperation_UpdateType_ITEM_MERGE;
  static const UpdateType ARRAY_INSERT =
    UpdateOperation_UpdateType_ARRAY_INSERT;
  static const UpdateType ARRAY_APPEND =
    UpdateOperation_UpdateType_ARRAY_APPEND;
  static inline bool UpdateType_IsValid(int value) {
    return UpdateOperation_UpdateType_IsValid(value);
  }
  static const UpdateType UpdateType_MIN =
    UpdateOperation_UpdateType_UpdateType_MIN;
  static const UpdateType UpdateType_MAX =
    UpdateOperation_UpdateType_UpdateType_MAX;
  static const int UpdateType_ARRAYSIZE =
    UpdateOperation_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UpdateType_descriptor() {
    return UpdateOperation_UpdateType_descriptor();
  }
  static inline const ::std::string& UpdateType_Name(UpdateType value) {
    return UpdateOperation_UpdateType_Name(value);
  }
  static inline bool UpdateType_Parse(const ::std::string& name,
      UpdateType* value) {
    return UpdateOperation_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::Mysqlx::Expr::ColumnIdentifier& source() const;
  ::Mysqlx::Expr::ColumnIdentifier* mutable_source();
  ::Mysqlx::Expr::ColumnIdentifier* release_source();
  void set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source);

  // optional .Mysqlx.Expr.Expr value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::Mysqlx::Expr::Expr& value() const;
  ::Mysqlx::Expr::Expr* mutable_value();
  ::Mysqlx::Expr::Expr* release_value();
  void set_allocated_value(::Mysqlx::Expr::Expr* value);

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 2;
  ::Mysqlx::Crud::UpdateOperation_UpdateType operation() const;
  void set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.UpdateOperation)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_operation();
  void clear_has_operation();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Mysqlx::Expr::ColumnIdentifier* source_;
  ::Mysqlx::Expr::Expr* value_;
  int operation_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Find : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Find) */ {
 public:
  Find();
  virtual ~Find();

  Find(const Find& from);

  inline Find& operator=(const Find& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Find& default_instance();

  static inline const Find* internal_default_instance() {
    return reinterpret_cast<const Find*>(
               &_Find_default_instance_);
  }

  void Swap(Find* other);

  // implements Message ----------------------------------------------

  inline Find* New() const PROTOBUF_FINAL { return New(NULL); }

  Find* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Find& from);
  void MergeFrom(const Find& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Find* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Crud.Projection projection = 4;
  int projection_size() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 4;
  const ::Mysqlx::Crud::Projection& projection(int index) const;
  ::Mysqlx::Crud::Projection* mutable_projection(int index);
  ::Mysqlx::Crud::Projection* add_projection();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
      mutable_projection();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
      projection() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 11;
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::Mysqlx::Datatypes::Scalar* add_args();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // repeated .Mysqlx.Crud.Order order = 7;
  int order_size() const;
  void clear_order();
  static const int kOrderFieldNumber = 7;
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::Mysqlx::Crud::Order* add_order();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  int grouping_size() const;
  void clear_grouping();
  static const int kGroupingFieldNumber = 8;
  const ::Mysqlx::Expr::Expr& grouping(int index) const;
  ::Mysqlx::Expr::Expr* mutable_grouping(int index);
  ::Mysqlx::Expr::Expr* add_grouping();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_grouping();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      grouping() const;

  // required .Mysqlx.Crud.Collection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* mutable_collection();
  ::Mysqlx::Crud::Collection* release_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Expr.Expr criteria = 5;
  bool has_criteria() const;
  void clear_criteria();
  static const int kCriteriaFieldNumber = 5;
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* mutable_criteria();
  ::Mysqlx::Expr::Expr* release_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // optional .Mysqlx.Crud.Limit limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* mutable_limit();
  ::Mysqlx::Crud::Limit* release_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  bool has_grouping_criteria() const;
  void clear_grouping_criteria();
  static const int kGroupingCriteriaFieldNumber = 9;
  const ::Mysqlx::Expr::Expr& grouping_criteria() const;
  ::Mysqlx::Expr::Expr* mutable_grouping_criteria();
  ::Mysqlx::Expr::Expr* release_grouping_criteria();
  void set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria);

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 3;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Find)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();
  void set_has_criteria();
  void clear_has_criteria();
  void set_has_limit();
  void clear_has_limit();
  void set_has_grouping_criteria();
  void clear_has_grouping_criteria();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection > projection_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > grouping_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  ::Mysqlx::Expr::Expr* grouping_criteria_;
  int data_model_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Insert_TypedRow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Insert.TypedRow) */ {
 public:
  Insert_TypedRow();
  virtual ~Insert_TypedRow();

  Insert_TypedRow(const Insert_TypedRow& from);

  inline Insert_TypedRow& operator=(const Insert_TypedRow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Insert_TypedRow& default_instance();

  static inline const Insert_TypedRow* internal_default_instance() {
    return reinterpret_cast<const Insert_TypedRow*>(
               &_Insert_TypedRow_default_instance_);
  }

  void Swap(Insert_TypedRow* other);

  // implements Message ----------------------------------------------

  inline Insert_TypedRow* New() const PROTOBUF_FINAL { return New(NULL); }

  Insert_TypedRow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Insert_TypedRow& from);
  void MergeFrom(const Insert_TypedRow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Insert_TypedRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr field = 1;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::Mysqlx::Expr::Expr& field(int index) const;
  ::Mysqlx::Expr::Expr* mutable_field(int index);
  ::Mysqlx::Expr::Expr* add_field();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_field();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      field() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert.TypedRow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > field_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Insert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Insert) */ {
 public:
  Insert();
  virtual ~Insert();

  Insert(const Insert& from);

  inline Insert& operator=(const Insert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Insert& default_instance();

  static inline const Insert* internal_default_instance() {
    return reinterpret_cast<const Insert*>(
               &_Insert_default_instance_);
  }

  void Swap(Insert* other);

  // implements Message ----------------------------------------------

  inline Insert* New() const PROTOBUF_FINAL { return New(NULL); }

  Insert* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Insert& from);
  void MergeFrom(const Insert& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Insert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Insert_TypedRow TypedRow;

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Crud.Column projection = 3;
  int projection_size() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 3;
  const ::Mysqlx::Crud::Column& projection(int index) const;
  ::Mysqlx::Crud::Column* mutable_projection(int index);
  ::Mysqlx::Crud::Column* add_projection();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >*
      mutable_projection();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >&
      projection() const;

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  int row_size() const;
  void clear_row();
  static const int kRowFieldNumber = 4;
  const ::Mysqlx::Crud::Insert_TypedRow& row(int index) const;
  ::Mysqlx::Crud::Insert_TypedRow* mutable_row(int index);
  ::Mysqlx::Crud::Insert_TypedRow* add_row();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
      mutable_row();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
      row() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 5;
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::Mysqlx::Datatypes::Scalar* add_args();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* mutable_collection();
  ::Mysqlx::Crud::Collection* release_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 2;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column > projection_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow > row_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  int data_model_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Update : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Update) */ {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Update& default_instance();

  static inline const Update* internal_default_instance() {
    return reinterpret_cast<const Update*>(
               &_Update_default_instance_);
  }

  void Swap(Update* other);

  // implements Message ----------------------------------------------

  inline Update* New() const PROTOBUF_FINAL { return New(NULL); }

  Update* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Update* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 8;
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::Mysqlx::Datatypes::Scalar* add_args();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // repeated .Mysqlx.Crud.Order order = 6;
  int order_size() const;
  void clear_order();
  static const int kOrderFieldNumber = 6;
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::Mysqlx::Crud::Order* add_order();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  int operation_size() const;
  void clear_operation();
  static const int kOperationFieldNumber = 7;
  const ::Mysqlx::Crud::UpdateOperation& operation(int index) const;
  ::Mysqlx::Crud::UpdateOperation* mutable_operation(int index);
  ::Mysqlx::Crud::UpdateOperation* add_operation();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
      mutable_operation();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
      operation() const;

  // required .Mysqlx.Crud.Collection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* mutable_collection();
  ::Mysqlx::Crud::Collection* release_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Expr.Expr criteria = 4;
  bool has_criteria() const;
  void clear_criteria();
  static const int kCriteriaFieldNumber = 4;
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* mutable_criteria();
  ::Mysqlx::Expr::Expr* release_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // optional .Mysqlx.Crud.Limit limit = 5;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 5;
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* mutable_limit();
  ::Mysqlx::Crud::Limit* release_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 3;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Update)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();
  void set_has_criteria();
  void clear_has_criteria();
  void set_has_limit();
  void clear_has_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation > operation_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  int data_model_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Delete) */ {
 public:
  Delete();
  virtual ~Delete();

  Delete(const Delete& from);

  inline Delete& operator=(const Delete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delete& default_instance();

  static inline const Delete* internal_default_instance() {
    return reinterpret_cast<const Delete*>(
               &_Delete_default_instance_);
  }

  void Swap(Delete* other);

  // implements Message ----------------------------------------------

  inline Delete* New() const PROTOBUF_FINAL { return New(NULL); }

  Delete* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delete& from);
  void MergeFrom(const Delete& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 6;
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::Mysqlx::Datatypes::Scalar* add_args();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // repeated .Mysqlx.Crud.Order order = 5;
  int order_size() const;
  void clear_order();
  static const int kOrderFieldNumber = 5;
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::Mysqlx::Crud::Order* add_order();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* mutable_collection();
  ::Mysqlx::Crud::Collection* release_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);

  // optional .Mysqlx.Expr.Expr criteria = 3;
  bool has_criteria() const;
  void clear_criteria();
  static const int kCriteriaFieldNumber = 3;
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* mutable_criteria();
  ::Mysqlx::Expr::Expr* release_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);

  // optional .Mysqlx.Crud.Limit limit = 4;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 4;
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* mutable_limit();
  ::Mysqlx::Crud::Limit* release_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  bool has_data_model() const;
  void clear_data_model();
  static const int kDataModelFieldNumber = 2;
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Delete)
 private:
  void set_has_collection();
  void clear_has_collection();
  void set_has_data_model();
  void clear_has_data_model();
  void set_has_criteria();
  void clear_has_criteria();
  void set_has_limit();
  void clear_has_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  int data_model_;
  friend struct  protobuf_mysqlx_5fcrud_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Column

// optional string name = 1;
inline bool Column::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Column::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.name)
  return name_.GetNoArena();
}
inline void Column::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.name)
}
#if LANG_CXX11
inline void Column::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.name)
}
#endif
inline void Column::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.name)
}
inline void Column::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.name)
}
inline ::std::string* Column::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.name)
}

// optional string alias = 2;
inline bool Column::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Column::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Column::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Column::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& Column::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.alias)
  return alias_.GetNoArena();
}
inline void Column::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.alias)
}
#if LANG_CXX11
inline void Column::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.alias)
}
#endif
inline void Column::set_alias(const char* value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.alias)
}
inline void Column::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.alias)
}
inline ::std::string* Column::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Column::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.alias)
}

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
inline int Column::document_path_size() const {
  return document_path_.size();
}
inline void Column::clear_document_path() {
  document_path_.Clear();
}
inline const ::Mysqlx::Expr::DocumentPathItem& Column::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.document_path)
  return document_path_.Get(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.document_path)
  return document_path_.Mutable(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Column.document_path)
  return document_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
Column::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Column.document_path)
  return &document_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
Column::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Column.document_path)
  return document_path_;
}

// -------------------------------------------------------------------

// Projection

// required .Mysqlx.Expr.Expr source = 1;
inline bool Projection::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Projection::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Projection::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Projection::clear_source() {
  if (source_ != NULL) source_->::Mysqlx::Expr::Expr::Clear();
  clear_has_source();
}
inline const ::Mysqlx::Expr::Expr& Projection::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.source)
  return source_ != NULL ? *source_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* Projection::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.source)
  return source_;
}
inline ::Mysqlx::Expr::Expr* Projection::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.source)
  clear_has_source();
  ::Mysqlx::Expr::Expr* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Projection::set_allocated_source(::Mysqlx::Expr::Expr* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.source)
}

// optional string alias = 2;
inline bool Projection::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Projection::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Projection::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Projection::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& Projection::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.alias)
  return alias_.GetNoArena();
}
inline void Projection::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Projection.alias)
}
#if LANG_CXX11
inline void Projection::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Projection.alias)
}
#endif
inline void Projection::set_alias(const char* value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Projection.alias)
}
inline void Projection::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Projection.alias)
}
inline ::std::string* Projection::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Projection::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Projection::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.alias)
}

// -------------------------------------------------------------------

// Collection

// required string name = 1;
inline bool Collection::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Collection::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Collection::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Collection::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Collection::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.name)
  return name_.GetNoArena();
}
inline void Collection::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.name)
}
#if LANG_CXX11
inline void Collection::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.name)
}
#endif
inline void Collection::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.name)
}
inline void Collection::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.name)
}
inline ::std::string* Collection::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Collection::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.name)
}

// optional string schema = 2;
inline bool Collection::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Collection::set_has_schema() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Collection::clear_has_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Collection::clear_schema() {
  schema_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema();
}
inline const ::std::string& Collection::schema() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.schema)
  return schema_.GetNoArena();
}
inline void Collection::set_schema(const ::std::string& value) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.schema)
}
#if LANG_CXX11
inline void Collection::set_schema(::std::string&& value) {
  set_has_schema();
  schema_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.schema)
}
#endif
inline void Collection::set_schema(const char* value) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.schema)
}
inline void Collection::set_schema(const char* value, size_t size) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.schema)
}
inline ::std::string* Collection::mutable_schema() {
  set_has_schema();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.schema)
  return schema_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Collection::release_schema() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.schema)
  clear_has_schema();
  return schema_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_schema(::std::string* schema) {
  if (schema != NULL) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  schema_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.schema)
}

// -------------------------------------------------------------------

// Limit

// required uint64 row_count = 1;
inline bool Limit::has_row_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limit::set_has_row_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limit::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limit::clear_row_count() {
  row_count_ = GOOGLE_ULONGLONG(0);
  clear_has_row_count();
}
inline ::google::protobuf::uint64 Limit::row_count() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.row_count)
  return row_count_;
}
inline void Limit::set_row_count(::google::protobuf::uint64 value) {
  set_has_row_count();
  row_count_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.row_count)
}

// optional uint64 offset = 2;
inline bool Limit::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limit::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limit::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.offset)
  return offset_;
}
inline void Limit::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.offset)
}

// -------------------------------------------------------------------

// Order

// required .Mysqlx.Expr.Expr expr = 1;
inline bool Order::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Order::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Order::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Order::clear_expr() {
  if (expr_ != NULL) expr_->::Mysqlx::Expr::Expr::Clear();
  clear_has_expr();
}
inline const ::Mysqlx::Expr::Expr& Order::expr() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.expr)
  return expr_ != NULL ? *expr_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* Order::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Order.expr)
  return expr_;
}
inline ::Mysqlx::Expr::Expr* Order::release_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Order.expr)
  clear_has_expr();
  ::Mysqlx::Expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Order::set_allocated_expr(::Mysqlx::Expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Order.expr)
}

// optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
inline bool Order::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Order::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Order::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Order::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::Mysqlx::Crud::Order_Direction Order::direction() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.direction)
  return static_cast< ::Mysqlx::Crud::Order_Direction >(direction_);
}
inline void Order::set_direction(::Mysqlx::Crud::Order_Direction value) {
  assert(::Mysqlx::Crud::Order_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Order.direction)
}

// -------------------------------------------------------------------

// UpdateOperation

// required .Mysqlx.Expr.ColumnIdentifier source = 1;
inline bool UpdateOperation::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateOperation::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateOperation::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateOperation::clear_source() {
  if (source_ != NULL) source_->::Mysqlx::Expr::ColumnIdentifier::Clear();
  clear_has_source();
}
inline const ::Mysqlx::Expr::ColumnIdentifier& UpdateOperation::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.source)
  return source_ != NULL ? *source_
                         : *::Mysqlx::Expr::ColumnIdentifier::internal_default_instance();
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::Mysqlx::Expr::ColumnIdentifier;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.source)
  return source_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.source)
  clear_has_source();
  ::Mysqlx::Expr::ColumnIdentifier* temp = source_;
  source_ = NULL;
  return temp;
}
inline void UpdateOperation::set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.source)
}

// required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
inline bool UpdateOperation::has_operation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateOperation::set_has_operation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateOperation::clear_has_operation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateOperation::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::Mysqlx::Crud::UpdateOperation_UpdateType UpdateOperation::operation() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.operation)
  return static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(operation_);
}
inline void UpdateOperation::set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value) {
  assert(::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.UpdateOperation.operation)
}

// optional .Mysqlx.Expr.Expr value = 3;
inline bool UpdateOperation::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateOperation::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateOperation::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateOperation::clear_value() {
  if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
  clear_has_value();
}
inline const ::Mysqlx::Expr::Expr& UpdateOperation::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.value)
  return value_ != NULL ? *value_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.value)
  return value_;
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.value)
  clear_has_value();
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline void UpdateOperation::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.value)
}

// -------------------------------------------------------------------

// Find

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Find::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Find::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Find::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Find::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Find::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
inline ::Mysqlx::Crud::Collection* Find::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Find::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Find::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Find::has_data_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Find::set_has_data_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Find::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Find::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Find::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Find::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.data_model)
}

// repeated .Mysqlx.Crud.Projection projection = 4;
inline int Find::projection_size() const {
  return projection_.size();
}
inline void Find::clear_projection() {
  projection_.Clear();
}
inline const ::Mysqlx::Crud::Projection& Find::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.projection)
  return projection_.Get(index);
}
inline ::Mysqlx::Crud::Projection* Find::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.projection)
  return projection_.Mutable(index);
}
inline ::Mysqlx::Crud::Projection* Find::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.projection)
  return projection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
Find::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.projection)
  return &projection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
Find::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.projection)
  return projection_;
}

// optional .Mysqlx.Expr.Expr criteria = 5;
inline bool Find::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Find::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Find::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Find::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Find::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.criteria)
  return criteria_ != NULL ? *criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* Find::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.criteria)
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline void Find::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 11;
inline int Find::args_size() const {
  return args_.size();
}
inline void Find::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Find::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Find::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Find::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.args)
  return args_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Find::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.args)
  return &args_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Find::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.args)
  return args_;
}

// optional .Mysqlx.Crud.Limit limit = 6;
inline bool Find::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Find::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Find::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Find::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Find::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.limit)
  return limit_ != NULL ? *limit_
                         : *::Mysqlx::Crud::Limit::internal_default_instance();
}
inline ::Mysqlx::Crud::Limit* Find::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    limit_ = new ::Mysqlx::Crud::Limit;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.limit)
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Find::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Find::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.limit)
}

// repeated .Mysqlx.Crud.Order order = 7;
inline int Find::order_size() const {
  return order_.size();
}
inline void Find::clear_order() {
  order_.Clear();
}
inline const ::Mysqlx::Crud::Order& Find::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Find::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.order)
  return order_.Mutable(index);
}
inline ::Mysqlx::Crud::Order* Find::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.order)
  return order_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Find::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.order)
  return &order_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Find::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.order)
  return order_;
}

// repeated .Mysqlx.Expr.Expr grouping = 8;
inline int Find::grouping_size() const {
  return grouping_.size();
}
inline void Find::clear_grouping() {
  grouping_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Find::grouping(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping)
  return grouping_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping)
  return grouping_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Find::add_grouping() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.grouping)
  return grouping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Find::mutable_grouping() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.grouping)
  return &grouping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Find::grouping() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.grouping)
  return grouping_;
}

// optional .Mysqlx.Expr.Expr grouping_criteria = 9;
inline bool Find::has_grouping_criteria() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Find::set_has_grouping_criteria() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Find::clear_has_grouping_criteria() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Find::clear_grouping_criteria() {
  if (grouping_criteria_ != NULL) grouping_criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_grouping_criteria();
}
inline const ::Mysqlx::Expr::Expr& Find::grouping_criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping_criteria)
  return grouping_criteria_ != NULL ? *grouping_criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping_criteria() {
  set_has_grouping_criteria();
  if (grouping_criteria_ == NULL) {
    grouping_criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping_criteria)
  return grouping_criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::release_grouping_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.grouping_criteria)
  clear_has_grouping_criteria();
  ::Mysqlx::Expr::Expr* temp = grouping_criteria_;
  grouping_criteria_ = NULL;
  return temp;
}
inline void Find::set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria) {
  delete grouping_criteria_;
  grouping_criteria_ = grouping_criteria;
  if (grouping_criteria) {
    set_has_grouping_criteria();
  } else {
    clear_has_grouping_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.grouping_criteria)
}

// -------------------------------------------------------------------

// Insert_TypedRow

// repeated .Mysqlx.Expr.Expr field = 1;
inline int Insert_TypedRow::field_size() const {
  return field_.size();
}
inline void Insert_TypedRow::clear_field() {
  field_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Insert_TypedRow::field(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::add_field() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Insert_TypedRow::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.TypedRow.field)
  return &field_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Insert_TypedRow::field() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.TypedRow.field)
  return field_;
}

// -------------------------------------------------------------------

// Insert

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Insert::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Insert::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Insert::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Insert::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Insert::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
inline ::Mysqlx::Crud::Collection* Insert::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Insert::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Insert.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Insert::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Insert.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Insert::has_data_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Insert::set_has_data_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Insert::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Insert::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Insert::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Insert::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Insert.data_model)
}

// repeated .Mysqlx.Crud.Column projection = 3;
inline int Insert::projection_size() const {
  return projection_.size();
}
inline void Insert::clear_projection() {
  projection_.Clear();
}
inline const ::Mysqlx::Crud::Column& Insert::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.projection)
  return projection_.Get(index);
}
inline ::Mysqlx::Crud::Column* Insert::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.projection)
  return projection_.Mutable(index);
}
inline ::Mysqlx::Crud::Column* Insert::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.projection)
  return projection_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >*
Insert::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.projection)
  return &projection_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >&
Insert::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.projection)
  return projection_;
}

// repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
inline int Insert::row_size() const {
  return row_.size();
}
inline void Insert::clear_row() {
  row_.Clear();
}
inline const ::Mysqlx::Crud::Insert_TypedRow& Insert::row(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.row)
  return row_.Get(index);
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.row)
  return row_.Mutable(index);
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::add_row() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.row)
  return row_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
Insert::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.row)
  return &row_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
Insert::row() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.row)
  return row_;
}

// repeated .Mysqlx.Datatypes.Scalar args = 5;
inline int Insert::args_size() const {
  return args_.size();
}
inline void Insert::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Insert::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Insert::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Insert::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.args)
  return args_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Insert::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.args)
  return &args_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Insert::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.args)
  return args_;
}

// -------------------------------------------------------------------

// Update

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Update::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Update::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Update::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Update::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Update::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
inline ::Mysqlx::Crud::Collection* Update::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Update::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Update::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Update::has_data_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Update::set_has_data_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Update::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Update::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Update::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Update::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Update.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 4;
inline bool Update::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Update::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Update::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Update::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Update::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.criteria)
  return criteria_ != NULL ? *criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* Update::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.criteria)
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Update::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline void Update::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 8;
inline int Update::args_size() const {
  return args_.size();
}
inline void Update::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Update::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Update::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Update::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.args)
  return args_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Update::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.args)
  return &args_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Update::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.args)
  return args_;
}

// optional .Mysqlx.Crud.Limit limit = 5;
inline bool Update::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Update::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Update::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Update::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Update::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.limit)
  return limit_ != NULL ? *limit_
                         : *::Mysqlx::Crud::Limit::internal_default_instance();
}
inline ::Mysqlx::Crud::Limit* Update::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    limit_ = new ::Mysqlx::Crud::Limit;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.limit)
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Update::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Update::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.limit)
}

// repeated .Mysqlx.Crud.Order order = 6;
inline int Update::order_size() const {
  return order_.size();
}
inline void Update::clear_order() {
  order_.Clear();
}
inline const ::Mysqlx::Crud::Order& Update::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Update::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.order)
  return order_.Mutable(index);
}
inline ::Mysqlx::Crud::Order* Update::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.order)
  return order_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Update::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.order)
  return &order_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Update::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.order)
  return order_;
}

// repeated .Mysqlx.Crud.UpdateOperation operation = 7;
inline int Update::operation_size() const {
  return operation_.size();
}
inline void Update::clear_operation() {
  operation_.Clear();
}
inline const ::Mysqlx::Crud::UpdateOperation& Update::operation(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.operation)
  return operation_.Get(index);
}
inline ::Mysqlx::Crud::UpdateOperation* Update::mutable_operation(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.operation)
  return operation_.Mutable(index);
}
inline ::Mysqlx::Crud::UpdateOperation* Update::add_operation() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.operation)
  return operation_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
Update::mutable_operation() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.operation)
  return &operation_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
Update::operation() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.operation)
  return operation_;
}

// -------------------------------------------------------------------

// Delete

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Delete::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Delete::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Delete::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Delete::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
inline const ::Mysqlx::Crud::Collection& Delete::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
inline ::Mysqlx::Crud::Collection* Delete::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.collection)
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Delete::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
inline void Delete::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Delete::has_data_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Delete::set_has_data_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Delete::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Delete::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
inline ::Mysqlx::Crud::DataModel Delete::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline void Delete::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Delete.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 3;
inline bool Delete::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Delete::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Delete::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Delete::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Delete::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.criteria)
  return criteria_ != NULL ? *criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* Delete::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.criteria)
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Delete::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
inline void Delete::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 6;
inline int Delete::args_size() const {
  return args_.size();
}
inline void Delete::clear_args() {
  args_.Clear();
}
inline const ::Mysqlx::Datatypes::Scalar& Delete::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.args)
  return args_.Get(index);
}
inline ::Mysqlx::Datatypes::Scalar* Delete::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.args)
  return args_.Mutable(index);
}
inline ::Mysqlx::Datatypes::Scalar* Delete::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.args)
  return args_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Delete::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.args)
  return &args_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Delete::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.args)
  return args_;
}

// optional .Mysqlx.Crud.Limit limit = 4;
inline bool Delete::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Delete::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Delete::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Delete::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
inline const ::Mysqlx::Crud::Limit& Delete::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.limit)
  return limit_ != NULL ? *limit_
                         : *::Mysqlx::Crud::Limit::internal_default_instance();
}
inline ::Mysqlx::Crud::Limit* Delete::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    limit_ = new ::Mysqlx::Crud::Limit;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.limit)
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Delete::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Delete::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.limit)
}

// repeated .Mysqlx.Crud.Order order = 5;
inline int Delete::order_size() const {
  return order_.size();
}
inline void Delete::clear_order() {
  order_.Clear();
}
inline const ::Mysqlx::Crud::Order& Delete::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.order)
  return order_.Get(index);
}
inline ::Mysqlx::Crud::Order* Delete::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.order)
  return order_.Mutable(index);
}
inline ::Mysqlx::Crud::Order* Delete::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.order)
  return order_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Delete::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.order)
  return &order_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Delete::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.order)
  return order_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Crud
}  // namespace Mysqlx

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Mysqlx::Crud::Order_Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::Order_Direction>() {
  return ::Mysqlx::Crud::Order_Direction_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::UpdateOperation_UpdateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::UpdateOperation_UpdateType>() {
  return ::Mysqlx::Crud::UpdateOperation_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Crud::DataModel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Crud::DataModel>() {
  return ::Mysqlx::Crud::DataModel_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mysqlx_5fcrud_2eproto__INCLUDED
