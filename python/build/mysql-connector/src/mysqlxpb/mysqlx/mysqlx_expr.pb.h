// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_expr.proto

#ifndef PROTOBUF_mysqlx_5fexpr_2eproto__INCLUDED
#define PROTOBUF_mysqlx_5fexpr_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
namespace Mysqlx {
namespace Datatypes {
class Any;
class AnyDefaultTypeInternal;
extern AnyDefaultTypeInternal _Any_default_instance_;
class Array;
class ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_ObjectField;
class Object_ObjectFieldDefaultTypeInternal;
extern Object_ObjectFieldDefaultTypeInternal _Object_ObjectField_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class Scalar_Octets;
class Scalar_OctetsDefaultTypeInternal;
extern Scalar_OctetsDefaultTypeInternal _Scalar_Octets_default_instance_;
class Scalar_String;
class Scalar_StringDefaultTypeInternal;
extern Scalar_StringDefaultTypeInternal _Scalar_String_default_instance_;
}  // namespace Datatypes
namespace Expr {
class Array;
class ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class ColumnIdentifier;
class ColumnIdentifierDefaultTypeInternal;
extern ColumnIdentifierDefaultTypeInternal _ColumnIdentifier_default_instance_;
class DocumentPathItem;
class DocumentPathItemDefaultTypeInternal;
extern DocumentPathItemDefaultTypeInternal _DocumentPathItem_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class FunctionCall;
class FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_ObjectField;
class Object_ObjectFieldDefaultTypeInternal;
extern Object_ObjectFieldDefaultTypeInternal _Object_ObjectField_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
}  // namespace Expr
}  // namespace Mysqlx

namespace Mysqlx {
namespace Expr {

namespace protobuf_mysqlx_5fexpr_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mysqlx_5fexpr_2eproto

enum Expr_Type {
  Expr_Type_IDENT = 1,
  Expr_Type_LITERAL = 2,
  Expr_Type_VARIABLE = 3,
  Expr_Type_FUNC_CALL = 4,
  Expr_Type_OPERATOR = 5,
  Expr_Type_PLACEHOLDER = 6,
  Expr_Type_OBJECT = 7,
  Expr_Type_ARRAY = 8
};
bool Expr_Type_IsValid(int value);
const Expr_Type Expr_Type_Type_MIN = Expr_Type_IDENT;
const Expr_Type Expr_Type_Type_MAX = Expr_Type_ARRAY;
const int Expr_Type_Type_ARRAYSIZE = Expr_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expr_Type_descriptor();
inline const ::std::string& Expr_Type_Name(Expr_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expr_Type_descriptor(), value);
}
inline bool Expr_Type_Parse(
    const ::std::string& name, Expr_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expr_Type>(
    Expr_Type_descriptor(), name, value);
}
enum DocumentPathItem_Type {
  DocumentPathItem_Type_MEMBER = 1,
  DocumentPathItem_Type_MEMBER_ASTERISK = 2,
  DocumentPathItem_Type_ARRAY_INDEX = 3,
  DocumentPathItem_Type_ARRAY_INDEX_ASTERISK = 4,
  DocumentPathItem_Type_DOUBLE_ASTERISK = 5
};
bool DocumentPathItem_Type_IsValid(int value);
const DocumentPathItem_Type DocumentPathItem_Type_Type_MIN = DocumentPathItem_Type_MEMBER;
const DocumentPathItem_Type DocumentPathItem_Type_Type_MAX = DocumentPathItem_Type_DOUBLE_ASTERISK;
const int DocumentPathItem_Type_Type_ARRAYSIZE = DocumentPathItem_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* DocumentPathItem_Type_descriptor();
inline const ::std::string& DocumentPathItem_Type_Name(DocumentPathItem_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    DocumentPathItem_Type_descriptor(), value);
}
inline bool DocumentPathItem_Type_Parse(
    const ::std::string& name, DocumentPathItem_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DocumentPathItem_Type>(
    DocumentPathItem_Type_descriptor(), name, value);
}
// ===================================================================

class Expr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }

  void Swap(Expr* other);

  // implements Message ----------------------------------------------

  inline Expr* New() const PROTOBUF_FINAL { return New(NULL); }

  Expr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Expr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Expr_Type Type;
  static const Type IDENT =
    Expr_Type_IDENT;
  static const Type LITERAL =
    Expr_Type_LITERAL;
  static const Type VARIABLE =
    Expr_Type_VARIABLE;
  static const Type FUNC_CALL =
    Expr_Type_FUNC_CALL;
  static const Type OPERATOR =
    Expr_Type_OPERATOR;
  static const Type PLACEHOLDER =
    Expr_Type_PLACEHOLDER;
  static const Type OBJECT =
    Expr_Type_OBJECT;
  static const Type ARRAY =
    Expr_Type_ARRAY;
  static inline bool Type_IsValid(int value) {
    return Expr_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Expr_Type_Type_MIN;
  static const Type Type_MAX =
    Expr_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Expr_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Expr_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Expr_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Expr_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string variable = 3;
  bool has_variable() const;
  void clear_variable();
  static const int kVariableFieldNumber = 3;
  const ::std::string& variable() const;
  void set_variable(const ::std::string& value);
  #if LANG_CXX11
  void set_variable(::std::string&& value);
  #endif
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  ::std::string* mutable_variable();
  ::std::string* release_variable();
  void set_allocated_variable(::std::string* variable);

  // optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  const ::Mysqlx::Expr::ColumnIdentifier& identifier() const;
  ::Mysqlx::Expr::ColumnIdentifier* mutable_identifier();
  ::Mysqlx::Expr::ColumnIdentifier* release_identifier();
  void set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier);

  // optional .Mysqlx.Datatypes.Scalar literal = 4;
  bool has_literal() const;
  void clear_literal();
  static const int kLiteralFieldNumber = 4;
  const ::Mysqlx::Datatypes::Scalar& literal() const;
  ::Mysqlx::Datatypes::Scalar* mutable_literal();
  ::Mysqlx::Datatypes::Scalar* release_literal();
  void set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal);

  // optional .Mysqlx.Expr.FunctionCall function_call = 5;
  bool has_function_call() const;
  void clear_function_call();
  static const int kFunctionCallFieldNumber = 5;
  const ::Mysqlx::Expr::FunctionCall& function_call() const;
  ::Mysqlx::Expr::FunctionCall* mutable_function_call();
  ::Mysqlx::Expr::FunctionCall* release_function_call();
  void set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call);

  // optional .Mysqlx.Expr.Operator operator = 6;
  bool has_operator_() const;
  void clear_operator_();
  static const int kOperatorFieldNumber = 6;
  const ::Mysqlx::Expr::Operator& operator_() const;
  ::Mysqlx::Expr::Operator* mutable_operator_();
  ::Mysqlx::Expr::Operator* release_operator_();
  void set_allocated_operator_(::Mysqlx::Expr::Operator* operator_);

  // optional .Mysqlx.Expr.Object object = 8;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 8;
  const ::Mysqlx::Expr::Object& object() const;
  ::Mysqlx::Expr::Object* mutable_object();
  ::Mysqlx::Expr::Object* release_object();
  void set_allocated_object(::Mysqlx::Expr::Object* object);

  // optional .Mysqlx.Expr.Array array = 9;
  bool has_array() const;
  void clear_array();
  static const int kArrayFieldNumber = 9;
  const ::Mysqlx::Expr::Array& array() const;
  ::Mysqlx::Expr::Array* mutable_array();
  ::Mysqlx::Expr::Array* release_array();
  void set_allocated_array(::Mysqlx::Expr::Array* array);

  // optional uint32 position = 7;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 7;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // required .Mysqlx.Expr.Expr.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Mysqlx::Expr::Expr_Type type() const;
  void set_type(::Mysqlx::Expr::Expr_Type value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Expr)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_identifier();
  void clear_has_identifier();
  void set_has_variable();
  void clear_has_variable();
  void set_has_literal();
  void clear_has_literal();
  void set_has_function_call();
  void clear_has_function_call();
  void set_has_operator_();
  void clear_has_operator_();
  void set_has_position();
  void clear_has_position();
  void set_has_object();
  void clear_has_object();
  void set_has_array();
  void clear_has_array();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr variable_;
  ::Mysqlx::Expr::ColumnIdentifier* identifier_;
  ::Mysqlx::Datatypes::Scalar* literal_;
  ::Mysqlx::Expr::FunctionCall* function_call_;
  ::Mysqlx::Expr::Operator* operator__;
  ::Mysqlx::Expr::Object* object_;
  ::Mysqlx::Expr::Array* array_;
  ::google::protobuf::uint32 position_;
  int type_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }

  void Swap(Identifier* other);

  // implements Message ----------------------------------------------

  inline Identifier* New() const PROTOBUF_FINAL { return New(NULL); }

  Identifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 2;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Identifier)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_schema_name();
  void clear_has_schema_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DocumentPathItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.DocumentPathItem) */ {
 public:
  DocumentPathItem();
  virtual ~DocumentPathItem();

  DocumentPathItem(const DocumentPathItem& from);

  inline DocumentPathItem& operator=(const DocumentPathItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentPathItem& default_instance();

  static inline const DocumentPathItem* internal_default_instance() {
    return reinterpret_cast<const DocumentPathItem*>(
               &_DocumentPathItem_default_instance_);
  }

  void Swap(DocumentPathItem* other);

  // implements Message ----------------------------------------------

  inline DocumentPathItem* New() const PROTOBUF_FINAL { return New(NULL); }

  DocumentPathItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DocumentPathItem& from);
  void MergeFrom(const DocumentPathItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DocumentPathItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DocumentPathItem_Type Type;
  static const Type MEMBER =
    DocumentPathItem_Type_MEMBER;
  static const Type MEMBER_ASTERISK =
    DocumentPathItem_Type_MEMBER_ASTERISK;
  static const Type ARRAY_INDEX =
    DocumentPathItem_Type_ARRAY_INDEX;
  static const Type ARRAY_INDEX_ASTERISK =
    DocumentPathItem_Type_ARRAY_INDEX_ASTERISK;
  static const Type DOUBLE_ASTERISK =
    DocumentPathItem_Type_DOUBLE_ASTERISK;
  static inline bool Type_IsValid(int value) {
    return DocumentPathItem_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DocumentPathItem_Type_Type_MIN;
  static const Type Type_MAX =
    DocumentPathItem_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DocumentPathItem_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return DocumentPathItem_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return DocumentPathItem_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return DocumentPathItem_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Mysqlx::Expr::DocumentPathItem_Type type() const;
  void set_type(::Mysqlx::Expr::DocumentPathItem_Type value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.DocumentPathItem)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint32 index_;
  int type_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ColumnIdentifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.ColumnIdentifier) */ {
 public:
  ColumnIdentifier();
  virtual ~ColumnIdentifier();

  ColumnIdentifier(const ColumnIdentifier& from);

  inline ColumnIdentifier& operator=(const ColumnIdentifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnIdentifier& default_instance();

  static inline const ColumnIdentifier* internal_default_instance() {
    return reinterpret_cast<const ColumnIdentifier*>(
               &_ColumnIdentifier_default_instance_);
  }

  void Swap(ColumnIdentifier* other);

  // implements Message ----------------------------------------------

  inline ColumnIdentifier* New() const PROTOBUF_FINAL { return New(NULL); }

  ColumnIdentifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ColumnIdentifier& from);
  void MergeFrom(const ColumnIdentifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ColumnIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
  int document_path_size() const;
  void clear_document_path();
  static const int kDocumentPathFieldNumber = 1;
  const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // optional string schema_name = 4;
  bool has_schema_name() const;
  void clear_schema_name();
  static const int kSchemaNameFieldNumber = 4;
  const ::std::string& schema_name() const;
  void set_schema_name(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_name(::std::string&& value);
  #endif
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  ::std::string* mutable_schema_name();
  ::std::string* release_schema_name();
  void set_allocated_schema_name(::std::string* schema_name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.ColumnIdentifier)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_table_name();
  void clear_has_table_name();
  void set_has_schema_name();
  void clear_has_schema_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::internal::ArenaStringPtr schema_name_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FunctionCall : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.FunctionCall) */ {
 public:
  FunctionCall();
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionCall& default_instance();

  static inline const FunctionCall* internal_default_instance() {
    return reinterpret_cast<const FunctionCall*>(
               &_FunctionCall_default_instance_);
  }

  void Swap(FunctionCall* other);

  // implements Message ----------------------------------------------

  inline FunctionCall* New() const PROTOBUF_FINAL { return New(NULL); }

  FunctionCall* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FunctionCall* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr param = 2;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  const ::Mysqlx::Expr::Expr& param(int index) const;
  ::Mysqlx::Expr::Expr* mutable_param(int index);
  ::Mysqlx::Expr::Expr* add_param();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;

  // required .Mysqlx.Expr.Identifier name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::Mysqlx::Expr::Identifier& name() const;
  ::Mysqlx::Expr::Identifier* mutable_name();
  ::Mysqlx::Expr::Identifier* release_name();
  void set_allocated_name(::Mysqlx::Expr::Identifier* name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.FunctionCall)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  ::Mysqlx::Expr::Identifier* name_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Operator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Operator) */ {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operator& default_instance();

  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }

  void Swap(Operator* other);

  // implements Message ----------------------------------------------

  inline Operator* New() const PROTOBUF_FINAL { return New(NULL); }

  Operator* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr param = 2;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 2;
  const ::Mysqlx::Expr::Expr& param(int index) const;
  ::Mysqlx::Expr::Expr* mutable_param(int index);
  ::Mysqlx::Expr::Expr* add_param();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Operator)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object_ObjectField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Object.ObjectField) */ {
 public:
  Object_ObjectField();
  virtual ~Object_ObjectField();

  Object_ObjectField(const Object_ObjectField& from);

  inline Object_ObjectField& operator=(const Object_ObjectField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object_ObjectField& default_instance();

  static inline const Object_ObjectField* internal_default_instance() {
    return reinterpret_cast<const Object_ObjectField*>(
               &_Object_ObjectField_default_instance_);
  }

  void Swap(Object_ObjectField* other);

  // implements Message ----------------------------------------------

  inline Object_ObjectField* New() const PROTOBUF_FINAL { return New(NULL); }

  Object_ObjectField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Object_ObjectField& from);
  void MergeFrom(const Object_ObjectField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Object_ObjectField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .Mysqlx.Expr.Expr value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::Mysqlx::Expr::Expr& value() const;
  ::Mysqlx::Expr::Expr* mutable_value();
  ::Mysqlx::Expr::Expr* release_value();
  void set_allocated_value(::Mysqlx::Expr::Expr* value);

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object.ObjectField)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::Mysqlx::Expr::Expr* value_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  inline Object* New() const PROTOBUF_FINAL { return New(NULL); }

  Object* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Object_ObjectField ObjectField;

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
  int fld_size() const;
  void clear_fld();
  static const int kFldFieldNumber = 1;
  const ::Mysqlx::Expr::Object_ObjectField& fld(int index) const;
  ::Mysqlx::Expr::Object_ObjectField* mutable_fld(int index);
  ::Mysqlx::Expr::Object_ObjectField* add_fld();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
      mutable_fld();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
      fld() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField > fld_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Array : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Array) */ {
 public:
  Array();
  virtual ~Array();

  Array(const Array& from);

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Array& default_instance();

  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
               &_Array_default_instance_);
  }

  void Swap(Array* other);

  // implements Message ----------------------------------------------

  inline Array* New() const PROTOBUF_FINAL { return New(NULL); }

  Array* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Array& from);
  void MergeFrom(const Array& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Array* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Mysqlx.Expr.Expr value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::Mysqlx::Expr::Expr& value(int index) const;
  ::Mysqlx::Expr::Expr* mutable_value(int index);
  ::Mysqlx::Expr::Expr* add_value();
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      value() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Array)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr > value_;
  friend struct  protobuf_mysqlx_5fexpr_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Expr

// required .Mysqlx.Expr.Expr.Type type = 1;
inline bool Expr::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Expr::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Expr::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Expr::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Mysqlx::Expr::Expr_Type Expr::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.type)
  return static_cast< ::Mysqlx::Expr::Expr_Type >(type_);
}
inline void Expr::set_type(::Mysqlx::Expr::Expr_Type value) {
  assert(::Mysqlx::Expr::Expr_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.type)
}

// optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
inline bool Expr::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr::clear_identifier() {
  if (identifier_ != NULL) identifier_->::Mysqlx::Expr::ColumnIdentifier::Clear();
  clear_has_identifier();
}
inline const ::Mysqlx::Expr::ColumnIdentifier& Expr::identifier() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.identifier)
  return identifier_ != NULL ? *identifier_
                         : *::Mysqlx::Expr::ColumnIdentifier::internal_default_instance();
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) {
    identifier_ = new ::Mysqlx::Expr::ColumnIdentifier;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.identifier)
  return identifier_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::release_identifier() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.identifier)
  clear_has_identifier();
  ::Mysqlx::Expr::ColumnIdentifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline void Expr::set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier) {
  delete identifier_;
  identifier_ = identifier;
  if (identifier) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.identifier)
}

// optional string variable = 3;
inline bool Expr::has_variable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr::set_has_variable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr::clear_has_variable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr::clear_variable() {
  variable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_variable();
}
inline const ::std::string& Expr::variable() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.variable)
  return variable_.GetNoArena();
}
inline void Expr::set_variable(const ::std::string& value) {
  set_has_variable();
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.variable)
}
#if LANG_CXX11
inline void Expr::set_variable(::std::string&& value) {
  set_has_variable();
  variable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Expr.variable)
}
#endif
inline void Expr::set_variable(const char* value) {
  set_has_variable();
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Expr.variable)
}
inline void Expr::set_variable(const char* value, size_t size) {
  set_has_variable();
  variable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Expr.variable)
}
inline ::std::string* Expr::mutable_variable() {
  set_has_variable();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.variable)
  return variable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expr::release_variable() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.variable)
  clear_has_variable();
  return variable_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expr::set_allocated_variable(::std::string* variable) {
  if (variable != NULL) {
    set_has_variable();
  } else {
    clear_has_variable();
  }
  variable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), variable);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.variable)
}

// optional .Mysqlx.Datatypes.Scalar literal = 4;
inline bool Expr::has_literal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expr::set_has_literal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expr::clear_has_literal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expr::clear_literal() {
  if (literal_ != NULL) literal_->::Mysqlx::Datatypes::Scalar::Clear();
  clear_has_literal();
}
inline const ::Mysqlx::Datatypes::Scalar& Expr::literal() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.literal)
  return literal_ != NULL ? *literal_
                         : *::Mysqlx::Datatypes::Scalar::internal_default_instance();
}
inline ::Mysqlx::Datatypes::Scalar* Expr::mutable_literal() {
  set_has_literal();
  if (literal_ == NULL) {
    literal_ = new ::Mysqlx::Datatypes::Scalar;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.literal)
  return literal_;
}
inline ::Mysqlx::Datatypes::Scalar* Expr::release_literal() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.literal)
  clear_has_literal();
  ::Mysqlx::Datatypes::Scalar* temp = literal_;
  literal_ = NULL;
  return temp;
}
inline void Expr::set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal) {
  delete literal_;
  literal_ = literal;
  if (literal) {
    set_has_literal();
  } else {
    clear_has_literal();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.literal)
}

// optional .Mysqlx.Expr.FunctionCall function_call = 5;
inline bool Expr::has_function_call() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expr::set_has_function_call() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expr::clear_has_function_call() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expr::clear_function_call() {
  if (function_call_ != NULL) function_call_->::Mysqlx::Expr::FunctionCall::Clear();
  clear_has_function_call();
}
inline const ::Mysqlx::Expr::FunctionCall& Expr::function_call() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.function_call)
  return function_call_ != NULL ? *function_call_
                         : *::Mysqlx::Expr::FunctionCall::internal_default_instance();
}
inline ::Mysqlx::Expr::FunctionCall* Expr::mutable_function_call() {
  set_has_function_call();
  if (function_call_ == NULL) {
    function_call_ = new ::Mysqlx::Expr::FunctionCall;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.function_call)
  return function_call_;
}
inline ::Mysqlx::Expr::FunctionCall* Expr::release_function_call() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.function_call)
  clear_has_function_call();
  ::Mysqlx::Expr::FunctionCall* temp = function_call_;
  function_call_ = NULL;
  return temp;
}
inline void Expr::set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call) {
  delete function_call_;
  function_call_ = function_call;
  if (function_call) {
    set_has_function_call();
  } else {
    clear_has_function_call();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.function_call)
}

// optional .Mysqlx.Expr.Operator operator = 6;
inline bool Expr::has_operator_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Expr::set_has_operator_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Expr::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Expr::clear_operator_() {
  if (operator__ != NULL) operator__->::Mysqlx::Expr::Operator::Clear();
  clear_has_operator_();
}
inline const ::Mysqlx::Expr::Operator& Expr::operator_() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.operator)
  return operator__ != NULL ? *operator__
                         : *::Mysqlx::Expr::Operator::internal_default_instance();
}
inline ::Mysqlx::Expr::Operator* Expr::mutable_operator_() {
  set_has_operator_();
  if (operator__ == NULL) {
    operator__ = new ::Mysqlx::Expr::Operator;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.operator)
  return operator__;
}
inline ::Mysqlx::Expr::Operator* Expr::release_operator_() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.operator)
  clear_has_operator_();
  ::Mysqlx::Expr::Operator* temp = operator__;
  operator__ = NULL;
  return temp;
}
inline void Expr::set_allocated_operator_(::Mysqlx::Expr::Operator* operator_) {
  delete operator__;
  operator__ = operator_;
  if (operator_) {
    set_has_operator_();
  } else {
    clear_has_operator_();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.operator)
}

// optional uint32 position = 7;
inline bool Expr::has_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Expr::set_has_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Expr::clear_has_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Expr::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Expr::position() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.position)
  return position_;
}
inline void Expr::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.position)
}

// optional .Mysqlx.Expr.Object object = 8;
inline bool Expr::has_object() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Expr::set_has_object() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Expr::clear_has_object() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Expr::clear_object() {
  if (object_ != NULL) object_->::Mysqlx::Expr::Object::Clear();
  clear_has_object();
}
inline const ::Mysqlx::Expr::Object& Expr::object() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.object)
  return object_ != NULL ? *object_
                         : *::Mysqlx::Expr::Object::internal_default_instance();
}
inline ::Mysqlx::Expr::Object* Expr::mutable_object() {
  set_has_object();
  if (object_ == NULL) {
    object_ = new ::Mysqlx::Expr::Object;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.object)
  return object_;
}
inline ::Mysqlx::Expr::Object* Expr::release_object() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.object)
  clear_has_object();
  ::Mysqlx::Expr::Object* temp = object_;
  object_ = NULL;
  return temp;
}
inline void Expr::set_allocated_object(::Mysqlx::Expr::Object* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.object)
}

// optional .Mysqlx.Expr.Array array = 9;
inline bool Expr::has_array() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Expr::set_has_array() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Expr::clear_has_array() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Expr::clear_array() {
  if (array_ != NULL) array_->::Mysqlx::Expr::Array::Clear();
  clear_has_array();
}
inline const ::Mysqlx::Expr::Array& Expr::array() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.array)
  return array_ != NULL ? *array_
                         : *::Mysqlx::Expr::Array::internal_default_instance();
}
inline ::Mysqlx::Expr::Array* Expr::mutable_array() {
  set_has_array();
  if (array_ == NULL) {
    array_ = new ::Mysqlx::Expr::Array;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.array)
  return array_;
}
inline ::Mysqlx::Expr::Array* Expr::release_array() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.array)
  clear_has_array();
  ::Mysqlx::Expr::Array* temp = array_;
  array_ = NULL;
  return temp;
}
inline void Expr::set_allocated_array(::Mysqlx::Expr::Array* array) {
  delete array_;
  array_ = array;
  if (array) {
    set_has_array();
  } else {
    clear_has_array();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.array)
}

// -------------------------------------------------------------------

// Identifier

// required string name = 1;
inline bool Identifier::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Identifier::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Identifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Identifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.name)
  return name_.GetNoArena();
}
inline void Identifier::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.name)
}
#if LANG_CXX11
inline void Identifier::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Identifier.name)
}
#endif
inline void Identifier::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Identifier.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.name)
}

// optional string schema_name = 2;
inline bool Identifier::has_schema_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Identifier::set_has_schema_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Identifier::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Identifier::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& Identifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.schema_name)
  return schema_name_.GetNoArena();
}
inline void Identifier::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.schema_name)
}
#if LANG_CXX11
inline void Identifier::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Identifier.schema_name)
}
#endif
inline void Identifier::set_schema_name(const char* value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.schema_name)
}
inline void Identifier::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.schema_name)
}
inline ::std::string* Identifier::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Identifier.schema_name)
  clear_has_schema_name();
  return schema_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.schema_name)
}

// -------------------------------------------------------------------

// DocumentPathItem

// required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
inline bool DocumentPathItem::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentPathItem::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentPathItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentPathItem::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Mysqlx::Expr::DocumentPathItem_Type DocumentPathItem::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.type)
  return static_cast< ::Mysqlx::Expr::DocumentPathItem_Type >(type_);
}
inline void DocumentPathItem::set_type(::Mysqlx::Expr::DocumentPathItem_Type value) {
  assert(::Mysqlx::Expr::DocumentPathItem_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.type)
}

// optional string value = 2;
inline bool DocumentPathItem::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentPathItem::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentPathItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentPathItem::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& DocumentPathItem::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.value)
  return value_.GetNoArena();
}
inline void DocumentPathItem::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.value)
}
#if LANG_CXX11
inline void DocumentPathItem::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.DocumentPathItem.value)
}
#endif
inline void DocumentPathItem::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.DocumentPathItem.value)
}
inline void DocumentPathItem::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.DocumentPathItem.value)
}
inline ::std::string* DocumentPathItem::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.DocumentPathItem.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DocumentPathItem::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.DocumentPathItem.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentPathItem::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.DocumentPathItem.value)
}

// optional uint32 index = 3;
inline bool DocumentPathItem::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentPathItem::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentPathItem::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentPathItem::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 DocumentPathItem::index() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.index)
  return index_;
}
inline void DocumentPathItem::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.index)
}

// -------------------------------------------------------------------

// ColumnIdentifier

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
inline int ColumnIdentifier::document_path_size() const {
  return document_path_.size();
}
inline void ColumnIdentifier::clear_document_path() {
  document_path_.Clear();
}
inline const ::Mysqlx::Expr::DocumentPathItem& ColumnIdentifier::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Get(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Mutable(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
ColumnIdentifier::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return &document_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
ColumnIdentifier::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_;
}

// optional string name = 2;
inline bool ColumnIdentifier::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnIdentifier::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnIdentifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnIdentifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ColumnIdentifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.name)
  return name_.GetNoArena();
}
inline void ColumnIdentifier::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.name)
}
#if LANG_CXX11
inline void ColumnIdentifier::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.name)
}
#endif
inline void ColumnIdentifier::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.name)
}
inline void ColumnIdentifier::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.name)
}
inline ::std::string* ColumnIdentifier::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.name)
}

// optional string table_name = 3;
inline bool ColumnIdentifier::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnIdentifier::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnIdentifier::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnIdentifier::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& ColumnIdentifier::table_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.table_name)
  return table_name_.GetNoArena();
}
inline void ColumnIdentifier::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.table_name)
}
#if LANG_CXX11
inline void ColumnIdentifier::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.table_name)
}
#endif
inline void ColumnIdentifier::set_table_name(const char* value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline void ColumnIdentifier::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline ::std::string* ColumnIdentifier::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnIdentifier::release_table_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.table_name)
  clear_has_table_name();
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.table_name)
}

// optional string schema_name = 4;
inline bool ColumnIdentifier::has_schema_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnIdentifier::set_has_schema_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnIdentifier::clear_has_schema_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnIdentifier::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema_name();
}
inline const ::std::string& ColumnIdentifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return schema_name_.GetNoArena();
}
inline void ColumnIdentifier::set_schema_name(const ::std::string& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
#if LANG_CXX11
inline void ColumnIdentifier::set_schema_name(::std::string&& value) {
  set_has_schema_name();
  schema_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
#endif
inline void ColumnIdentifier::set_schema_name(const char* value) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline void ColumnIdentifier::set_schema_name(const char* value, size_t size) {
  set_has_schema_name();
  schema_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline ::std::string* ColumnIdentifier::mutable_schema_name() {
  set_has_schema_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return schema_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnIdentifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.schema_name)
  clear_has_schema_name();
  return schema_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_schema_name(::std::string* schema_name) {
  if (schema_name != NULL) {
    set_has_schema_name();
  } else {
    clear_has_schema_name();
  }
  schema_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.schema_name)
}

// -------------------------------------------------------------------

// FunctionCall

// required .Mysqlx.Expr.Identifier name = 1;
inline bool FunctionCall::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionCall::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionCall::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionCall::clear_name() {
  if (name_ != NULL) name_->::Mysqlx::Expr::Identifier::Clear();
  clear_has_name();
}
inline const ::Mysqlx::Expr::Identifier& FunctionCall::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.name)
  return name_ != NULL ? *name_
                         : *::Mysqlx::Expr::Identifier::internal_default_instance();
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::mutable_name() {
  set_has_name();
  if (name_ == NULL) {
    name_ = new ::Mysqlx::Expr::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.name)
  return name_;
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.FunctionCall.name)
  clear_has_name();
  ::Mysqlx::Expr::Identifier* temp = name_;
  name_ = NULL;
  return temp;
}
inline void FunctionCall::set_allocated_name(::Mysqlx::Expr::Identifier* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.FunctionCall.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int FunctionCall::param_size() const {
  return param_.size();
}
inline void FunctionCall::clear_param() {
  param_.Clear();
}
inline const ::Mysqlx::Expr::Expr& FunctionCall::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.param)
  return param_.Get(index);
}
inline ::Mysqlx::Expr::Expr* FunctionCall::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.param)
  return param_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* FunctionCall::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.FunctionCall.param)
  return param_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
FunctionCall::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.FunctionCall.param)
  return &param_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
FunctionCall::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.FunctionCall.param)
  return param_;
}

// -------------------------------------------------------------------

// Operator

// required string name = 1;
inline bool Operator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operator::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Operator::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.name)
  return name_.GetNoArena();
}
inline void Operator::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Operator.name)
}
#if LANG_CXX11
inline void Operator::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Operator.name)
}
#endif
inline void Operator::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Operator.name)
}
inline void Operator::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Operator.name)
}
inline ::std::string* Operator::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operator::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Operator.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operator::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Operator.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int Operator::param_size() const {
  return param_.size();
}
inline void Operator::clear_param() {
  param_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Operator::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.param)
  return param_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Operator::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.param)
  return param_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Operator::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Operator.param)
  return param_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Operator::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Operator.param)
  return &param_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Operator::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Operator.param)
  return param_;
}

// -------------------------------------------------------------------

// Object_ObjectField

// required string key = 1;
inline bool Object_ObjectField::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object_ObjectField::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object_ObjectField::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object_ObjectField::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Object_ObjectField::key() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.key)
  return key_.GetNoArena();
}
inline void Object_ObjectField::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Object.ObjectField.key)
}
#if LANG_CXX11
inline void Object_ObjectField::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Object.ObjectField.key)
}
#endif
inline void Object_ObjectField::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Object.ObjectField.key)
}
inline void Object_ObjectField::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Object.ObjectField.key)
}
inline ::std::string* Object_ObjectField::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object_ObjectField::release_key() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Object.ObjectField.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object_ObjectField::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.key)
}

// required .Mysqlx.Expr.Expr value = 2;
inline bool Object_ObjectField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object_ObjectField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object_ObjectField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object_ObjectField::clear_value() {
  if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
  clear_has_value();
}
inline const ::Mysqlx::Expr::Expr& Object_ObjectField::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.value)
  return value_ != NULL ? *value_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.value)
  return value_;
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Object.ObjectField.value)
  clear_has_value();
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Object_ObjectField::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.value)
}

// -------------------------------------------------------------------

// Object

// repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
inline int Object::fld_size() const {
  return fld_.size();
}
inline void Object::clear_fld() {
  fld_.Clear();
}
inline const ::Mysqlx::Expr::Object_ObjectField& Object::fld(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.fld)
  return fld_.Get(index);
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::mutable_fld(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.fld)
  return fld_.Mutable(index);
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::add_fld() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Object.fld)
  return fld_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
Object::mutable_fld() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Object.fld)
  return &fld_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
Object::fld() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Object.fld)
  return fld_;
}

// -------------------------------------------------------------------

// Array

// repeated .Mysqlx.Expr.Expr value = 1;
inline int Array::value_size() const {
  return value_.size();
}
inline void Array::clear_value() {
  value_.Clear();
}
inline const ::Mysqlx::Expr::Expr& Array::value(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Array.value)
  return value_.Get(index);
}
inline ::Mysqlx::Expr::Expr* Array::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Array.value)
  return value_.Mutable(index);
}
inline ::Mysqlx::Expr::Expr* Array::add_value() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Array.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Array::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Array.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Array::value() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Array.value)
  return value_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Expr
}  // namespace Mysqlx

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Mysqlx::Expr::Expr_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Expr::Expr_Type>() {
  return ::Mysqlx::Expr::Expr_Type_descriptor();
}
template <> struct is_proto_enum< ::Mysqlx::Expr::DocumentPathItem_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mysqlx::Expr::DocumentPathItem_Type>() {
  return ::Mysqlx::Expr::DocumentPathItem_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mysqlx_5fexpr_2eproto__INCLUDED
