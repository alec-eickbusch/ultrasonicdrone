// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mysqlx_crud.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Mysqlx {
namespace Crud {
class ColumnDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Column> {
} _Column_default_instance_;
class ProjectionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Projection> {
} _Projection_default_instance_;
class CollectionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Collection> {
} _Collection_default_instance_;
class LimitDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Limit> {
} _Limit_default_instance_;
class OrderDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Order> {
} _Order_default_instance_;
class UpdateOperationDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<UpdateOperation> {
} _UpdateOperation_default_instance_;
class FindDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Find> {
} _Find_default_instance_;
class Insert_TypedRowDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Insert_TypedRow> {
} _Insert_TypedRow_default_instance_;
class InsertDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Insert> {
} _Insert_default_instance_;
class UpdateDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Update> {
} _Update_default_instance_;
class DeleteDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Delete> {
} _Delete_default_instance_;

namespace protobuf_mysqlx_5fcrud_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[11];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[3];

}  // namespace

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, alias_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Column, document_path_),
  0,
  1,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, source_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Projection, alias_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Collection, schema_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, row_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, offset_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, expr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Order, direction_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, source_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, operation_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOperation, value_),
  0,
  2,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, projection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, criteria_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, args_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, order_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, grouping_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Find, grouping_criteria_),
  0,
  4,
  ~0u,
  1,
  ~0u,
  2,
  ~0u,
  ~0u,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert_TypedRow, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert_TypedRow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert_TypedRow, field_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, projection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, row_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Insert, args_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, criteria_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, args_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, order_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Update, operation_),
  0,
  3,
  1,
  ~0u,
  2,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, collection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, data_model_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, criteria_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, args_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Delete, order_),
  0,
  3,
  1,
  ~0u,
  2,
  ~0u,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 7, sizeof(Column)},
  { 10, 16, sizeof(Projection)},
  { 18, 24, sizeof(Collection)},
  { 26, 32, sizeof(Limit)},
  { 34, 40, sizeof(Order)},
  { 42, 49, sizeof(UpdateOperation)},
  { 52, 65, sizeof(Find)},
  { 74, 79, sizeof(Insert_TypedRow)},
  { 80, 89, sizeof(Insert)},
  { 94, 105, sizeof(Update)},
  { 112, 122, sizeof(Delete)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_Column_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Projection_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Collection_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Limit_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Order_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_UpdateOperation_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Find_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Insert_TypedRow_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Insert_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Update_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Delete_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "mysqlx_crud.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 11);
}

}  // namespace

void TableStruct::Shutdown() {
  _Column_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _Projection_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _Collection_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _Limit_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _Order_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _UpdateOperation_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _Find_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _Insert_TypedRow_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  _Insert_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _Update_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  _Delete_default_instance_.Shutdown();
  delete file_level_metadata[10].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::Mysqlx::Expr::protobuf_mysqlx_5fexpr_2eproto::InitDefaults();
  ::Mysqlx::Datatypes::protobuf_mysqlx_5fdatatypes_2eproto::InitDefaults();
  _Column_default_instance_.DefaultConstruct();
  _Projection_default_instance_.DefaultConstruct();
  _Collection_default_instance_.DefaultConstruct();
  _Limit_default_instance_.DefaultConstruct();
  _Order_default_instance_.DefaultConstruct();
  _UpdateOperation_default_instance_.DefaultConstruct();
  _Find_default_instance_.DefaultConstruct();
  _Insert_TypedRow_default_instance_.DefaultConstruct();
  _Insert_default_instance_.DefaultConstruct();
  _Update_default_instance_.DefaultConstruct();
  _Delete_default_instance_.DefaultConstruct();
  _Projection_default_instance_.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  _Order_default_instance_.get_mutable()->expr_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  _UpdateOperation_default_instance_.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(
      ::Mysqlx::Expr::ColumnIdentifier::internal_default_instance());
  _UpdateOperation_default_instance_.get_mutable()->value_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  _Find_default_instance_.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  _Find_default_instance_.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  _Find_default_instance_.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  _Find_default_instance_.get_mutable()->grouping_criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  _Insert_default_instance_.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  _Update_default_instance_.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  _Update_default_instance_.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  _Update_default_instance_.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  _Delete_default_instance_.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  _Delete_default_instance_.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  _Delete_default_instance_.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\021mysqlx_crud.proto\022\013Mysqlx.Crud\032\021mysqlx"
      "_expr.proto\032\026mysqlx_datatypes.proto\"[\n\006C"
      "olumn\022\014\n\004name\030\001 \001(\t\022\r\n\005alias\030\002 \001(\t\0224\n\rdo"
      "cument_path\030\003 \003(\0132\035.Mysqlx.Expr.Document"
      "PathItem\">\n\nProjection\022!\n\006source\030\001 \002(\0132\021"
      ".Mysqlx.Expr.Expr\022\r\n\005alias\030\002 \001(\t\"*\n\nColl"
      "ection\022\014\n\004name\030\001 \002(\t\022\016\n\006schema\030\002 \001(\t\"*\n\005"
      "Limit\022\021\n\trow_count\030\001 \002(\004\022\016\n\006offset\030\002 \001(\004"
      "\"~\n\005Order\022\037\n\004expr\030\001 \002(\0132\021.Mysqlx.Expr.Ex"
      "pr\0224\n\tdirection\030\002 \001(\0162\034.Mysqlx.Crud.Orde"
      "r.Direction:\003ASC\"\036\n\tDirection\022\007\n\003ASC\020\001\022\010"
      "\n\004DESC\020\002\"\232\002\n\017UpdateOperation\022-\n\006source\030\001"
      " \002(\0132\035.Mysqlx.Expr.ColumnIdentifier\022:\n\to"
      "peration\030\002 \002(\0162\'.Mysqlx.Crud.UpdateOpera"
      "tion.UpdateType\022 \n\005value\030\003 \001(\0132\021.Mysqlx."
      "Expr.Expr\"z\n\nUpdateType\022\007\n\003SET\020\001\022\017\n\013ITEM"
      "_REMOVE\020\002\022\014\n\010ITEM_SET\020\003\022\020\n\014ITEM_REPLACE\020"
      "\004\022\016\n\nITEM_MERGE\020\005\022\020\n\014ARRAY_INSERT\020\006\022\020\n\014A"
      "RRAY_APPEND\020\007\"\362\002\n\004Find\022+\n\ncollection\030\002 \002"
      "(\0132\027.Mysqlx.Crud.Collection\022*\n\ndata_mode"
      "l\030\003 \001(\0162\026.Mysqlx.Crud.DataModel\022+\n\nproje"
      "ction\030\004 \003(\0132\027.Mysqlx.Crud.Projection\022#\n\010"
      "criteria\030\005 \001(\0132\021.Mysqlx.Expr.Expr\022&\n\004arg"
      "s\030\013 \003(\0132\030.Mysqlx.Datatypes.Scalar\022!\n\005lim"
      "it\030\006 \001(\0132\022.Mysqlx.Crud.Limit\022!\n\005order\030\007 "
      "\003(\0132\022.Mysqlx.Crud.Order\022#\n\010grouping\030\010 \003("
      "\0132\021.Mysqlx.Expr.Expr\022,\n\021grouping_criteri"
      "a\030\t \001(\0132\021.Mysqlx.Expr.Expr\"\213\002\n\006Insert\022+\n"
      "\ncollection\030\001 \002(\0132\027.Mysqlx.Crud.Collecti"
      "on\022*\n\ndata_model\030\002 \001(\0162\026.Mysqlx.Crud.Dat"
      "aModel\022\'\n\nprojection\030\003 \003(\0132\023.Mysqlx.Crud"
      ".Column\022)\n\003row\030\004 \003(\0132\034.Mysqlx.Crud.Inser"
      "t.TypedRow\022&\n\004args\030\005 \003(\0132\030.Mysqlx.Dataty"
      "pes.Scalar\032,\n\010TypedRow\022 \n\005field\030\001 \003(\0132\021."
      "Mysqlx.Expr.Expr\"\245\002\n\006Update\022+\n\ncollectio"
      "n\030\002 \002(\0132\027.Mysqlx.Crud.Collection\022*\n\ndata"
      "_model\030\003 \001(\0162\026.Mysqlx.Crud.DataModel\022#\n\010"
      "criteria\030\004 \001(\0132\021.Mysqlx.Expr.Expr\022&\n\004arg"
      "s\030\010 \003(\0132\030.Mysqlx.Datatypes.Scalar\022!\n\005lim"
      "it\030\005 \001(\0132\022.Mysqlx.Crud.Limit\022!\n\005order\030\006 "
      "\003(\0132\022.Mysqlx.Crud.Order\022/\n\toperation\030\007 \003"
      "(\0132\034.Mysqlx.Crud.UpdateOperation\"\364\001\n\006Del"
      "ete\022+\n\ncollection\030\001 \002(\0132\027.Mysqlx.Crud.Co"
      "llection\022*\n\ndata_model\030\002 \001(\0162\026.Mysqlx.Cr"
      "ud.DataModel\022#\n\010criteria\030\003 \001(\0132\021.Mysqlx."
      "Expr.Expr\022&\n\004args\030\006 \003(\0132\030.Mysqlx.Datatyp"
      "es.Scalar\022!\n\005limit\030\004 \001(\0132\022.Mysqlx.Crud.L"
      "imit\022!\n\005order\030\005 \003(\0132\022.Mysqlx.Crud.Order*"
      "$\n\tDataModel\022\014\n\010DOCUMENT\020\001\022\t\n\005TABLE\020\002B\036\n"
      "\034com.mysql.cj.mysqlx.protobuf"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 1989);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "mysqlx_crud.proto", &protobuf_RegisterTypes);
  ::Mysqlx::Expr::protobuf_mysqlx_5fexpr_2eproto::AddDescriptors();
  ::Mysqlx::Datatypes::protobuf_mysqlx_5fdatatypes_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_mysqlx_5fcrud_2eproto

const ::google::protobuf::EnumDescriptor* Order_Direction_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[0];
}
bool Order_Direction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Order_Direction Order::ASC;
const Order_Direction Order::DESC;
const Order_Direction Order::Direction_MIN;
const Order_Direction Order::Direction_MAX;
const int Order::Direction_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* UpdateOperation_UpdateType_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[1];
}
bool UpdateOperation_UpdateType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const UpdateOperation_UpdateType UpdateOperation::SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REMOVE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_SET;
const UpdateOperation_UpdateType UpdateOperation::ITEM_REPLACE;
const UpdateOperation_UpdateType UpdateOperation::ITEM_MERGE;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_INSERT;
const UpdateOperation_UpdateType UpdateOperation::ARRAY_APPEND;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MIN;
const UpdateOperation_UpdateType UpdateOperation::UpdateType_MAX;
const int UpdateOperation::UpdateType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* DataModel_descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_enum_descriptors[2];
}
bool DataModel_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Column::kNameFieldNumber;
const int Column::kAliasFieldNumber;
const int Column::kDocumentPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Column::Column()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Column)
}
Column::Column(const Column& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      document_path_(from.document_path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_alias()) {
    alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Column)
}

void Column::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Column)
  SharedDtor();
}

void Column::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Column::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Column::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[0].descriptor;
}

const Column& Column::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Column* Column::New(::google::protobuf::Arena* arena) const {
  Column* n = new Column;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Column::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Column)
  document_path_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (has_alias()) {
      GOOGLE_DCHECK(!alias_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*alias_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Column::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Column)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Column.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->alias().data(), this->alias().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Column.alias");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
      case 3: {
        if (tag == 26u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_document_path()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Column)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Column)
  return false;
#undef DO_
}

void Column::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Column)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.alias");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (unsigned int i = 0, n = this->document_path_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->document_path(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Column)
}

::google::protobuf::uint8* Column::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Column)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Column.alias");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->alias(), target);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (unsigned int i = 0, n = this->document_path_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->document_path(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Column)
  return target;
}

size_t Column::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Column)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  {
    unsigned int count = this->document_path_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->document_path(i));
    }
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string alias = 2;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->alias());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Column::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Column)
  GOOGLE_DCHECK_NE(&from, this);
  const Column* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Column>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Column)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Column)
    MergeFrom(*source);
  }
}

void Column::MergeFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Column)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  document_path_.MergeFrom(from.document_path_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_alias()) {
      set_has_alias();
      alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
  }
}

void Column::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Column)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Column::CopyFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Column)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->document_path())) return false;
  return true;
}

void Column::Swap(Column* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Column::InternalSwap(Column* other) {
  document_path_.UnsafeArenaSwap(&other->document_path_);
  name_.Swap(&other->name_);
  alias_.Swap(&other->alias_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Column::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[0];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Column

// optional string name = 1;
bool Column::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Column::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Column::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.name)
  return name_.GetNoArena();
}
void Column::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.name)
}
#if LANG_CXX11
void Column::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.name)
}
#endif
void Column::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.name)
}
void Column::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.name)
}
::std::string* Column::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Column::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.name)
}

// optional string alias = 2;
bool Column::has_alias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Column::set_has_alias() {
  _has_bits_[0] |= 0x00000002u;
}
void Column::clear_has_alias() {
  _has_bits_[0] &= ~0x00000002u;
}
void Column::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
const ::std::string& Column::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.alias)
  return alias_.GetNoArena();
}
void Column::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.alias)
}
#if LANG_CXX11
void Column::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.alias)
}
#endif
void Column::set_alias(const char* value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.alias)
}
void Column::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.alias)
}
::std::string* Column::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Column::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Column::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.alias)
}

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
int Column::document_path_size() const {
  return document_path_.size();
}
void Column::clear_document_path() {
  document_path_.Clear();
}
const ::Mysqlx::Expr::DocumentPathItem& Column::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.document_path)
  return document_path_.Get(index);
}
::Mysqlx::Expr::DocumentPathItem* Column::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.document_path)
  return document_path_.Mutable(index);
}
::Mysqlx::Expr::DocumentPathItem* Column::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Column.document_path)
  return document_path_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
Column::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Column.document_path)
  return &document_path_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
Column::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Column.document_path)
  return document_path_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Projection::kSourceFieldNumber;
const int Projection::kAliasFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Projection::Projection()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Projection)
}
Projection::Projection(const Projection& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_alias()) {
    alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  if (from.has_source()) {
    source_ = new ::Mysqlx::Expr::Expr(*from.source_);
  } else {
    source_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Projection)
}

void Projection::SharedCtor() {
  _cached_size_ = 0;
  alias_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = NULL;
}

Projection::~Projection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Projection)
  SharedDtor();
}

void Projection::SharedDtor() {
  alias_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete source_;
  }
}

void Projection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Projection::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[1].descriptor;
}

const Projection& Projection::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Projection* Projection::New(::google::protobuf::Arena* arena) const {
  Projection* n = new Projection;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Projection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Projection)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_alias()) {
      GOOGLE_DCHECK(!alias_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*alias_.UnsafeRawStringPointer())->clear();
    }
    if (has_source()) {
      GOOGLE_DCHECK(source_ != NULL);
      source_->::Mysqlx::Expr::Expr::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Projection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Projection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr source = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string alias = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_alias()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->alias().data(), this->alias().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Projection.alias");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Projection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Projection)
  return false;
#undef DO_
}

void Projection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Projection)
  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->source_, output);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Projection.alias");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->alias(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Projection)
}

::google::protobuf::uint8* Projection::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Projection)
  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->source_, false, target);
  }

  // optional string alias = 2;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->alias().data(), this->alias().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Projection.alias");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->alias(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Projection)
  return target;
}

size_t Projection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Projection)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .Mysqlx.Expr.Expr source = 1;
  if (has_source()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->source_);
  }
  // optional string alias = 2;
  if (has_alias()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->alias());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Projection::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Projection)
  GOOGLE_DCHECK_NE(&from, this);
  const Projection* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Projection>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Projection)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Projection)
    MergeFrom(*source);
  }
}

void Projection::MergeFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Projection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_alias()) {
      set_has_alias();
      alias_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
    if (from.has_source()) {
      mutable_source()->::Mysqlx::Expr::Expr::MergeFrom(from.source());
    }
  }
}

void Projection::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Projection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Projection::CopyFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Projection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  return true;
}

void Projection::Swap(Projection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Projection::InternalSwap(Projection* other) {
  alias_.Swap(&other->alias_);
  std::swap(source_, other->source_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Projection::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[1];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Projection

// required .Mysqlx.Expr.Expr source = 1;
bool Projection::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Projection::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
void Projection::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
void Projection::clear_source() {
  if (source_ != NULL) source_->::Mysqlx::Expr::Expr::Clear();
  clear_has_source();
}
const ::Mysqlx::Expr::Expr& Projection::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.source)
  return source_ != NULL ? *source_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
::Mysqlx::Expr::Expr* Projection::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.source)
  return source_;
}
::Mysqlx::Expr::Expr* Projection::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.source)
  clear_has_source();
  ::Mysqlx::Expr::Expr* temp = source_;
  source_ = NULL;
  return temp;
}
void Projection::set_allocated_source(::Mysqlx::Expr::Expr* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.source)
}

// optional string alias = 2;
bool Projection::has_alias() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Projection::set_has_alias() {
  _has_bits_[0] |= 0x00000001u;
}
void Projection::clear_has_alias() {
  _has_bits_[0] &= ~0x00000001u;
}
void Projection::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
const ::std::string& Projection::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.alias)
  return alias_.GetNoArena();
}
void Projection::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Projection.alias)
}
#if LANG_CXX11
void Projection::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Projection.alias)
}
#endif
void Projection::set_alias(const char* value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Projection.alias)
}
void Projection::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Projection.alias)
}
::std::string* Projection::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Projection::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Projection::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.alias)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Collection::kNameFieldNumber;
const int Collection::kSchemaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Collection::Collection()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Collection)
}
Collection::Collection(const Collection& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  schema_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_schema()) {
    schema_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.schema_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Collection)
}

void Collection::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Collection::~Collection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Collection)
  SharedDtor();
}

void Collection::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  schema_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Collection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Collection::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[2].descriptor;
}

const Collection& Collection::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Collection* Collection::New(::google::protobuf::Arena* arena) const {
  Collection* n = new Collection;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Collection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Collection)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (has_schema()) {
      GOOGLE_DCHECK(!schema_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*schema_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Collection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Collection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Collection.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string schema = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_schema()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->schema().data(), this->schema().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "Mysqlx.Crud.Collection.schema");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Collection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Collection)
  return false;
#undef DO_
}

void Collection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Collection)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string schema = 2;
  if (has_schema()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->schema().data(), this->schema().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.schema");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->schema(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Collection)
}

::google::protobuf::uint8* Collection::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Collection)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string schema = 2;
  if (has_schema()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->schema().data(), this->schema().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "Mysqlx.Crud.Collection.schema");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->schema(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Collection)
  return target;
}

size_t Collection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Collection)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // optional string schema = 2;
  if (has_schema()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->schema());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Collection::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Collection)
  GOOGLE_DCHECK_NE(&from, this);
  const Collection* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Collection>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Collection)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Collection)
    MergeFrom(*source);
  }
}

void Collection::MergeFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Collection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_schema()) {
      set_has_schema();
      schema_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.schema_);
    }
  }
}

void Collection::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Collection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Collection::CopyFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Collection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Collection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Collection::Swap(Collection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Collection::InternalSwap(Collection* other) {
  name_.Swap(&other->name_);
  schema_.Swap(&other->schema_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Collection::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[2];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Collection

// required string name = 1;
bool Collection::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Collection::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Collection::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Collection::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& Collection::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.name)
  return name_.GetNoArena();
}
void Collection::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.name)
}
#if LANG_CXX11
void Collection::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.name)
}
#endif
void Collection::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.name)
}
void Collection::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.name)
}
::std::string* Collection::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Collection::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Collection::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.name)
}

// optional string schema = 2;
bool Collection::has_schema() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Collection::set_has_schema() {
  _has_bits_[0] |= 0x00000002u;
}
void Collection::clear_has_schema() {
  _has_bits_[0] &= ~0x00000002u;
}
void Collection::clear_schema() {
  schema_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schema();
}
const ::std::string& Collection::schema() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.schema)
  return schema_.GetNoArena();
}
void Collection::set_schema(const ::std::string& value) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.schema)
}
#if LANG_CXX11
void Collection::set_schema(::std::string&& value) {
  set_has_schema();
  schema_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.schema)
}
#endif
void Collection::set_schema(const char* value) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.schema)
}
void Collection::set_schema(const char* value, size_t size) {
  set_has_schema();
  schema_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.schema)
}
::std::string* Collection::mutable_schema() {
  set_has_schema();
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.schema)
  return schema_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Collection::release_schema() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.schema)
  clear_has_schema();
  return schema_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Collection::set_allocated_schema(::std::string* schema) {
  if (schema != NULL) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
  schema_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.schema)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Limit::kRowCountFieldNumber;
const int Limit::kOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Limit::Limit()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Limit)
}
Limit::Limit(const Limit& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&row_count_, &from.row_count_,
    reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&row_count_) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Limit)
}

void Limit::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&row_count_, 0, reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&row_count_) + sizeof(offset_));
}

Limit::~Limit() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Limit)
  SharedDtor();
}

void Limit::SharedDtor() {
}

void Limit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Limit::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[3].descriptor;
}

const Limit& Limit::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Limit* Limit::New(::google::protobuf::Arena* arena) const {
  Limit* n = new Limit;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Limit::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Limit)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&row_count_, 0, reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&row_count_) + sizeof(offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Limit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 row_count = 1;
      case 1: {
        if (tag == 8u) {
          set_has_row_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &row_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 offset = 2;
      case 2: {
        if (tag == 16u) {
          set_has_offset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Limit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Limit)
  return false;
#undef DO_
}

void Limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Limit)
  // required uint64 row_count = 1;
  if (has_row_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->row_count(), output);
  }

  // optional uint64 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->offset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Limit)
}

::google::protobuf::uint8* Limit::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Limit)
  // required uint64 row_count = 1;
  if (has_row_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->row_count(), target);
  }

  // optional uint64 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->offset(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Limit)
  return target;
}

size_t Limit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Limit)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required uint64 row_count = 1;
  if (has_row_count()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->row_count());
  }
  // optional uint64 offset = 2;
  if (has_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->offset());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Limit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Limit)
  GOOGLE_DCHECK_NE(&from, this);
  const Limit* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Limit>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Limit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Limit)
    MergeFrom(*source);
  }
}

void Limit::MergeFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Limit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_row_count()) {
      set_row_count(from.row_count());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
}

void Limit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Limit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Limit::CopyFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Limit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Limit::Swap(Limit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Limit::InternalSwap(Limit* other) {
  std::swap(row_count_, other->row_count_);
  std::swap(offset_, other->offset_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Limit::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[3];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Limit

// required uint64 row_count = 1;
bool Limit::has_row_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Limit::set_has_row_count() {
  _has_bits_[0] |= 0x00000001u;
}
void Limit::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000001u;
}
void Limit::clear_row_count() {
  row_count_ = GOOGLE_ULONGLONG(0);
  clear_has_row_count();
}
::google::protobuf::uint64 Limit::row_count() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.row_count)
  return row_count_;
}
void Limit::set_row_count(::google::protobuf::uint64 value) {
  set_has_row_count();
  row_count_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.row_count)
}

// optional uint64 offset = 2;
bool Limit::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Limit::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
void Limit::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
void Limit::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
::google::protobuf::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.offset)
  return offset_;
}
void Limit::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.offset)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Order::kExprFieldNumber;
const int Order::kDirectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Order::Order()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Order)
}
Order::Order(const Order& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_expr()) {
    expr_ = new ::Mysqlx::Expr::Expr(*from.expr_);
  } else {
    expr_ = NULL;
  }
  direction_ = from.direction_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Order)
}

void Order::SharedCtor() {
  _cached_size_ = 0;
  expr_ = NULL;
  direction_ = 1;
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Order)
  SharedDtor();
}

void Order::SharedDtor() {
  if (this != internal_default_instance()) {
    delete expr_;
  }
}

void Order::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Order::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[4].descriptor;
}

const Order& Order::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Order* Order::New(::google::protobuf::Arena* arena) const {
  Order* n = new Order;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Order::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Order)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_expr()) {
      GOOGLE_DCHECK(expr_ != NULL);
      expr_->::Mysqlx::Expr::Expr::Clear();
    }
    direction_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Order::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Order)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.Expr expr = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
      case 2: {
        if (tag == 16u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::Order_Direction_IsValid(value)) {
            set_direction(static_cast< ::Mysqlx::Crud::Order_Direction >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Order)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Order)
  return false;
#undef DO_
}

void Order::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Order)
  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->expr_, output);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Order)
}

::google::protobuf::uint8* Order::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Order)
  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->expr_, false, target);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->direction(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Order)
  return target;
}

size_t Order::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Order)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .Mysqlx.Expr.Expr expr = 1;
  if (has_expr()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->expr_);
  }
  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (has_direction()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Order::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Order)
  GOOGLE_DCHECK_NE(&from, this);
  const Order* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Order>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Order)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Order)
    MergeFrom(*source);
  }
}

void Order::MergeFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Order)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_expr()) {
      mutable_expr()->::Mysqlx::Expr::Expr::MergeFrom(from.expr());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
}

void Order::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Order::CopyFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  return true;
}

void Order::Swap(Order* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Order::InternalSwap(Order* other) {
  std::swap(expr_, other->expr_);
  std::swap(direction_, other->direction_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Order::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[4];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Order

// required .Mysqlx.Expr.Expr expr = 1;
bool Order::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Order::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
void Order::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
void Order::clear_expr() {
  if (expr_ != NULL) expr_->::Mysqlx::Expr::Expr::Clear();
  clear_has_expr();
}
const ::Mysqlx::Expr::Expr& Order::expr() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.expr)
  return expr_ != NULL ? *expr_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
::Mysqlx::Expr::Expr* Order::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Order.expr)
  return expr_;
}
::Mysqlx::Expr::Expr* Order::release_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Order.expr)
  clear_has_expr();
  ::Mysqlx::Expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
void Order::set_allocated_expr(::Mysqlx::Expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Order.expr)
}

// optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
bool Order::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Order::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
void Order::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
void Order::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
::Mysqlx::Crud::Order_Direction Order::direction() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.direction)
  return static_cast< ::Mysqlx::Crud::Order_Direction >(direction_);
}
void Order::set_direction(::Mysqlx::Crud::Order_Direction value) {
  assert(::Mysqlx::Crud::Order_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Order.direction)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UpdateOperation::kSourceFieldNumber;
const int UpdateOperation::kOperationFieldNumber;
const int UpdateOperation::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UpdateOperation::UpdateOperation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.UpdateOperation)
}
UpdateOperation::UpdateOperation(const UpdateOperation& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_source()) {
    source_ = new ::Mysqlx::Expr::ColumnIdentifier(*from.source_);
  } else {
    source_ = NULL;
  }
  if (from.has_value()) {
    value_ = new ::Mysqlx::Expr::Expr(*from.value_);
  } else {
    value_ = NULL;
  }
  operation_ = from.operation_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&source_, 0, reinterpret_cast<char*>(&value_) -
    reinterpret_cast<char*>(&source_) + sizeof(value_));
  operation_ = 1;
}

UpdateOperation::~UpdateOperation() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.UpdateOperation)
  SharedDtor();
}

void UpdateOperation::SharedDtor() {
  if (this != internal_default_instance()) {
    delete source_;
  }
  if (this != internal_default_instance()) {
    delete value_;
  }
}

void UpdateOperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateOperation::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[5].descriptor;
}

const UpdateOperation& UpdateOperation::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

UpdateOperation* UpdateOperation::New(::google::protobuf::Arena* arena) const {
  UpdateOperation* n = new UpdateOperation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UpdateOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.UpdateOperation)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_source()) {
      GOOGLE_DCHECK(source_ != NULL);
      source_->::Mysqlx::Expr::ColumnIdentifier::Clear();
    }
    if (has_value()) {
      GOOGLE_DCHECK(value_ != NULL);
      value_->::Mysqlx::Expr::Expr::Clear();
    }
    operation_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UpdateOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.UpdateOperation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Expr.ColumnIdentifier source = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
      case 2: {
        if (tag == 16u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value)) {
            set_operation(static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr value = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.UpdateOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.UpdateOperation)
  return false;
#undef DO_
}

void UpdateOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.UpdateOperation)
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->source_, output);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (has_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->operation(), output);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.UpdateOperation)
}

::google::protobuf::uint8* UpdateOperation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.UpdateOperation)
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->source_, false, target);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (has_operation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->operation(), target);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->value_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.UpdateOperation)
  return target;
}

size_t UpdateOperation::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  if (has_source()) {
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->source_);
  }

  if (has_operation()) {
    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
  }

  return total_size;
}
size_t UpdateOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->source_);

    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .Mysqlx.Expr.Expr value = 3;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->value_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateOperation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.UpdateOperation)
  GOOGLE_DCHECK_NE(&from, this);
  const UpdateOperation* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UpdateOperation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.UpdateOperation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.UpdateOperation)
    MergeFrom(*source);
  }
}

void UpdateOperation::MergeFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.UpdateOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 7u) {
    if (from.has_source()) {
      mutable_source()->::Mysqlx::Expr::ColumnIdentifier::MergeFrom(from.source());
    }
    if (from.has_value()) {
      mutable_value()->::Mysqlx::Expr::Expr::MergeFrom(from.value());
    }
    if (from.has_operation()) {
      set_operation(from.operation());
    }
  }
}

void UpdateOperation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.UpdateOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateOperation::CopyFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.UpdateOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value_->IsInitialized()) return false;
  }
  return true;
}

void UpdateOperation::Swap(UpdateOperation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UpdateOperation::InternalSwap(UpdateOperation* other) {
  std::swap(source_, other->source_);
  std::swap(value_, other->value_);
  std::swap(operation_, other->operation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UpdateOperation::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[5];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UpdateOperation

// required .Mysqlx.Expr.ColumnIdentifier source = 1;
bool UpdateOperation::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UpdateOperation::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void UpdateOperation::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void UpdateOperation::clear_source() {
  if (source_ != NULL) source_->::Mysqlx::Expr::ColumnIdentifier::Clear();
  clear_has_source();
}
const ::Mysqlx::Expr::ColumnIdentifier& UpdateOperation::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.source)
  return source_ != NULL ? *source_
                         : *::Mysqlx::Expr::ColumnIdentifier::internal_default_instance();
}
::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::Mysqlx::Expr::ColumnIdentifier;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.source)
  return source_;
}
::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.source)
  clear_has_source();
  ::Mysqlx::Expr::ColumnIdentifier* temp = source_;
  source_ = NULL;
  return temp;
}
void UpdateOperation::set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.source)
}

// required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
bool UpdateOperation::has_operation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void UpdateOperation::set_has_operation() {
  _has_bits_[0] |= 0x00000004u;
}
void UpdateOperation::clear_has_operation() {
  _has_bits_[0] &= ~0x00000004u;
}
void UpdateOperation::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
::Mysqlx::Crud::UpdateOperation_UpdateType UpdateOperation::operation() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.operation)
  return static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(operation_);
}
void UpdateOperation::set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value) {
  assert(::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.UpdateOperation.operation)
}

// optional .Mysqlx.Expr.Expr value = 3;
bool UpdateOperation::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void UpdateOperation::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void UpdateOperation::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void UpdateOperation::clear_value() {
  if (value_ != NULL) value_->::Mysqlx::Expr::Expr::Clear();
  clear_has_value();
}
const ::Mysqlx::Expr::Expr& UpdateOperation::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.value)
  return value_ != NULL ? *value_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
::Mysqlx::Expr::Expr* UpdateOperation::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.value)
  return value_;
}
::Mysqlx::Expr::Expr* UpdateOperation::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.value)
  clear_has_value();
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
void UpdateOperation::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Find::kCollectionFieldNumber;
const int Find::kDataModelFieldNumber;
const int Find::kProjectionFieldNumber;
const int Find::kCriteriaFieldNumber;
const int Find::kArgsFieldNumber;
const int Find::kLimitFieldNumber;
const int Find::kOrderFieldNumber;
const int Find::kGroupingFieldNumber;
const int Find::kGroupingCriteriaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Find::Find()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Find)
}
Find::Find(const Find& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      projection_(from.projection_),
      args_(from.args_),
      order_(from.order_),
      grouping_(from.grouping_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  if (from.has_grouping_criteria()) {
    grouping_criteria_ = new ::Mysqlx::Expr::Expr(*from.grouping_criteria_);
  } else {
    grouping_criteria_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Find)
}

void Find::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&collection_, 0, reinterpret_cast<char*>(&grouping_criteria_) -
    reinterpret_cast<char*>(&collection_) + sizeof(grouping_criteria_));
  data_model_ = 1;
}

Find::~Find() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Find)
  SharedDtor();
}

void Find::SharedDtor() {
  if (this != internal_default_instance()) {
    delete collection_;
  }
  if (this != internal_default_instance()) {
    delete criteria_;
  }
  if (this != internal_default_instance()) {
    delete limit_;
  }
  if (this != internal_default_instance()) {
    delete grouping_criteria_;
  }
}

void Find::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Find::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[6].descriptor;
}

const Find& Find::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Find* Find::New(::google::protobuf::Arena* arena) const {
  Find* n = new Find;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Find::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Find)
  projection_.Clear();
  args_.Clear();
  order_.Clear();
  grouping_.Clear();
  if (_has_bits_[0 / 32] & 31u) {
    if (has_collection()) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->::Mysqlx::Crud::Collection::Clear();
    }
    if (has_criteria()) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->::Mysqlx::Crud::Limit::Clear();
    }
    if (has_grouping_criteria()) {
      GOOGLE_DCHECK(grouping_criteria_ != NULL);
      grouping_criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Find::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Find)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (tag == 24u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Projection projection = 4;
      case 4: {
        if (tag == 34u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 5;
      case 5: {
        if (tag == 42u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 6;
      case 6: {
        if (tag == 50u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 7;
      case 7: {
        if (tag == 58u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Mysqlx.Expr.Expr grouping = 8;
      case 8: {
        if (tag == 66u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_grouping()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
      case 9: {
        if (tag == 74u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_grouping_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 11;
      case 11: {
        if (tag == 90u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Find)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Find)
  return false;
#undef DO_
}

void Find::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Find)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->collection_, output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (unsigned int i = 0, n = this->projection_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->projection(i), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->criteria_, output);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->limit_, output);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (unsigned int i = 0, n = this->order_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->order(i), output);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (unsigned int i = 0, n = this->grouping_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->grouping(i), output);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (has_grouping_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->grouping_criteria_, output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->args(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Find)
}

::google::protobuf::uint8* Find::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Find)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->collection_, false, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->data_model(), target);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (unsigned int i = 0, n = this->projection_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->projection(i), false, target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (has_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->criteria_, false, target);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->limit_, false, target);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (unsigned int i = 0, n = this->order_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->order(i), false, target);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (unsigned int i = 0, n = this->grouping_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, this->grouping(i), false, target);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (has_grouping_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->grouping_criteria_, false, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, this->args(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Find)
  return target;
}

size_t Find::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Find)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->collection_);
  }
  // repeated .Mysqlx.Crud.Projection projection = 4;
  {
    unsigned int count = this->projection_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->projection(i));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  {
    unsigned int count = this->args_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->args(i));
    }
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  {
    unsigned int count = this->order_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->order(i));
    }
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  {
    unsigned int count = this->grouping_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->grouping(i));
    }
  }

  if (_has_bits_[0 / 32] & 30u) {
    // optional .Mysqlx.Expr.Expr criteria = 5;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 6;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->limit_);
    }

    // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
    if (has_grouping_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->grouping_criteria_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Find::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Find)
  GOOGLE_DCHECK_NE(&from, this);
  const Find* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Find>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Find)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Find)
    MergeFrom(*source);
  }
}

void Find::MergeFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Find)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  projection_.MergeFrom(from.projection_);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  grouping_.MergeFrom(from.grouping_);
  if (from._has_bits_[0 / 32] & 31u) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (from.has_grouping_criteria()) {
      mutable_grouping_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.grouping_criteria());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
  }
}

void Find::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Find)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Find::CopyFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Find)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Find::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->grouping())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  if (has_grouping_criteria()) {
    if (!this->grouping_criteria_->IsInitialized()) return false;
  }
  return true;
}

void Find::Swap(Find* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Find::InternalSwap(Find* other) {
  projection_.UnsafeArenaSwap(&other->projection_);
  args_.UnsafeArenaSwap(&other->args_);
  order_.UnsafeArenaSwap(&other->order_);
  grouping_.UnsafeArenaSwap(&other->grouping_);
  std::swap(collection_, other->collection_);
  std::swap(criteria_, other->criteria_);
  std::swap(limit_, other->limit_);
  std::swap(grouping_criteria_, other->grouping_criteria_);
  std::swap(data_model_, other->data_model_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Find::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[6];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Find

// required .Mysqlx.Crud.Collection collection = 2;
bool Find::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Find::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
void Find::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
void Find::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
const ::Mysqlx::Crud::Collection& Find::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
::Mysqlx::Crud::Collection* Find::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.collection)
  return collection_;
}
::Mysqlx::Crud::Collection* Find::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
void Find::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
bool Find::has_data_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Find::set_has_data_model() {
  _has_bits_[0] |= 0x00000010u;
}
void Find::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000010u;
}
void Find::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
::Mysqlx::Crud::DataModel Find::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
void Find::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.data_model)
}

// repeated .Mysqlx.Crud.Projection projection = 4;
int Find::projection_size() const {
  return projection_.size();
}
void Find::clear_projection() {
  projection_.Clear();
}
const ::Mysqlx::Crud::Projection& Find::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.projection)
  return projection_.Get(index);
}
::Mysqlx::Crud::Projection* Find::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.projection)
  return projection_.Mutable(index);
}
::Mysqlx::Crud::Projection* Find::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.projection)
  return projection_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
Find::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.projection)
  return &projection_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
Find::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.projection)
  return projection_;
}

// optional .Mysqlx.Expr.Expr criteria = 5;
bool Find::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Find::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
void Find::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
void Find::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
const ::Mysqlx::Expr::Expr& Find::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.criteria)
  return criteria_ != NULL ? *criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
::Mysqlx::Expr::Expr* Find::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.criteria)
  return criteria_;
}
::Mysqlx::Expr::Expr* Find::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
void Find::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 11;
int Find::args_size() const {
  return args_.size();
}
void Find::clear_args() {
  args_.Clear();
}
const ::Mysqlx::Datatypes::Scalar& Find::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.args)
  return args_.Get(index);
}
::Mysqlx::Datatypes::Scalar* Find::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.args)
  return args_.Mutable(index);
}
::Mysqlx::Datatypes::Scalar* Find::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.args)
  return args_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Find::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.args)
  return &args_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Find::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.args)
  return args_;
}

// optional .Mysqlx.Crud.Limit limit = 6;
bool Find::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Find::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
void Find::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
void Find::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
const ::Mysqlx::Crud::Limit& Find::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.limit)
  return limit_ != NULL ? *limit_
                         : *::Mysqlx::Crud::Limit::internal_default_instance();
}
::Mysqlx::Crud::Limit* Find::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    limit_ = new ::Mysqlx::Crud::Limit;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.limit)
  return limit_;
}
::Mysqlx::Crud::Limit* Find::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
void Find::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.limit)
}

// repeated .Mysqlx.Crud.Order order = 7;
int Find::order_size() const {
  return order_.size();
}
void Find::clear_order() {
  order_.Clear();
}
const ::Mysqlx::Crud::Order& Find::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.order)
  return order_.Get(index);
}
::Mysqlx::Crud::Order* Find::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.order)
  return order_.Mutable(index);
}
::Mysqlx::Crud::Order* Find::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.order)
  return order_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Find::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.order)
  return &order_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Find::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.order)
  return order_;
}

// repeated .Mysqlx.Expr.Expr grouping = 8;
int Find::grouping_size() const {
  return grouping_.size();
}
void Find::clear_grouping() {
  grouping_.Clear();
}
const ::Mysqlx::Expr::Expr& Find::grouping(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping)
  return grouping_.Get(index);
}
::Mysqlx::Expr::Expr* Find::mutable_grouping(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping)
  return grouping_.Mutable(index);
}
::Mysqlx::Expr::Expr* Find::add_grouping() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.grouping)
  return grouping_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Find::mutable_grouping() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.grouping)
  return &grouping_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Find::grouping() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.grouping)
  return grouping_;
}

// optional .Mysqlx.Expr.Expr grouping_criteria = 9;
bool Find::has_grouping_criteria() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Find::set_has_grouping_criteria() {
  _has_bits_[0] |= 0x00000008u;
}
void Find::clear_has_grouping_criteria() {
  _has_bits_[0] &= ~0x00000008u;
}
void Find::clear_grouping_criteria() {
  if (grouping_criteria_ != NULL) grouping_criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_grouping_criteria();
}
const ::Mysqlx::Expr::Expr& Find::grouping_criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping_criteria)
  return grouping_criteria_ != NULL ? *grouping_criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
::Mysqlx::Expr::Expr* Find::mutable_grouping_criteria() {
  set_has_grouping_criteria();
  if (grouping_criteria_ == NULL) {
    grouping_criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping_criteria)
  return grouping_criteria_;
}
::Mysqlx::Expr::Expr* Find::release_grouping_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.grouping_criteria)
  clear_has_grouping_criteria();
  ::Mysqlx::Expr::Expr* temp = grouping_criteria_;
  grouping_criteria_ = NULL;
  return temp;
}
void Find::set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria) {
  delete grouping_criteria_;
  grouping_criteria_ = grouping_criteria;
  if (grouping_criteria) {
    set_has_grouping_criteria();
  } else {
    clear_has_grouping_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.grouping_criteria)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Insert_TypedRow::kFieldFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Insert_TypedRow::Insert_TypedRow()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert.TypedRow)
}
Insert_TypedRow::Insert_TypedRow(const Insert_TypedRow& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      field_(from.field_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::SharedCtor() {
  _cached_size_ = 0;
}

Insert_TypedRow::~Insert_TypedRow() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert.TypedRow)
  SharedDtor();
}

void Insert_TypedRow::SharedDtor() {
}

void Insert_TypedRow::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Insert_TypedRow::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[7].descriptor;
}

const Insert_TypedRow& Insert_TypedRow::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Insert_TypedRow* Insert_TypedRow::New(::google::protobuf::Arena* arena) const {
  Insert_TypedRow* n = new Insert_TypedRow;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Insert_TypedRow::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert.TypedRow)
  field_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Insert_TypedRow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert.TypedRow)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Mysqlx.Expr.Expr field = 1;
      case 1: {
        if (tag == 10u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_field()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert.TypedRow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert.TypedRow)
  return false;
#undef DO_
}

void Insert_TypedRow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert.TypedRow)
  // repeated .Mysqlx.Expr.Expr field = 1;
  for (unsigned int i = 0, n = this->field_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->field(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert.TypedRow)
}

::google::protobuf::uint8* Insert_TypedRow::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert.TypedRow)
  // repeated .Mysqlx.Expr.Expr field = 1;
  for (unsigned int i = 0, n = this->field_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->field(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert.TypedRow)
  return target;
}

size_t Insert_TypedRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert.TypedRow)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .Mysqlx.Expr.Expr field = 1;
  {
    unsigned int count = this->field_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->field(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Insert_TypedRow::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Insert.TypedRow)
  GOOGLE_DCHECK_NE(&from, this);
  const Insert_TypedRow* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Insert_TypedRow>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Insert.TypedRow)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Insert.TypedRow)
    MergeFrom(*source);
  }
}

void Insert_TypedRow::MergeFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert.TypedRow)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  field_.MergeFrom(from.field_);
}

void Insert_TypedRow::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Insert.TypedRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Insert_TypedRow::CopyFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert.TypedRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert_TypedRow::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->field())) return false;
  return true;
}

void Insert_TypedRow::Swap(Insert_TypedRow* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Insert_TypedRow::InternalSwap(Insert_TypedRow* other) {
  field_.UnsafeArenaSwap(&other->field_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Insert_TypedRow::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[7];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Insert_TypedRow

// repeated .Mysqlx.Expr.Expr field = 1;
int Insert_TypedRow::field_size() const {
  return field_.size();
}
void Insert_TypedRow::clear_field() {
  field_.Clear();
}
const ::Mysqlx::Expr::Expr& Insert_TypedRow::field(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Get(index);
}
::Mysqlx::Expr::Expr* Insert_TypedRow::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Mutable(index);
}
::Mysqlx::Expr::Expr* Insert_TypedRow::add_field() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Insert_TypedRow::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.TypedRow.field)
  return &field_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Insert_TypedRow::field() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.TypedRow.field)
  return field_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Insert::kCollectionFieldNumber;
const int Insert::kDataModelFieldNumber;
const int Insert::kProjectionFieldNumber;
const int Insert::kRowFieldNumber;
const int Insert::kArgsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Insert::Insert()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert)
}
Insert::Insert(const Insert& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      projection_(from.projection_),
      row_(from.row_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert)
}

void Insert::SharedCtor() {
  _cached_size_ = 0;
  collection_ = NULL;
  data_model_ = 1;
}

Insert::~Insert() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert)
  SharedDtor();
}

void Insert::SharedDtor() {
  if (this != internal_default_instance()) {
    delete collection_;
  }
}

void Insert::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Insert::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[8].descriptor;
}

const Insert& Insert::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Insert* Insert::New(::google::protobuf::Arena* arena) const {
  Insert* n = new Insert;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Insert::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert)
  projection_.Clear();
  row_.Clear();
  args_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    if (has_collection()) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->::Mysqlx::Crud::Collection::Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Insert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Insert)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (tag == 16u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Column projection = 3;
      case 3: {
        if (tag == 26u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_projection()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
      case 4: {
        if (tag == 34u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_row()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 5;
      case 5: {
        if (tag == 42u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Insert)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Insert)
  return false;
#undef DO_
}

void Insert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Insert)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->collection_, output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (unsigned int i = 0, n = this->projection_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->projection(i), output);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (unsigned int i = 0, n = this->row_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->row(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->args(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Insert)
}

::google::protobuf::uint8* Insert::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->collection_, false, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->data_model(), target);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (unsigned int i = 0, n = this->projection_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->projection(i), false, target);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (unsigned int i = 0, n = this->row_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->row(i), false, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->args(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert)
  return target;
}

size_t Insert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->collection_);
  }
  // repeated .Mysqlx.Crud.Column projection = 3;
  {
    unsigned int count = this->projection_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->projection(i));
    }
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  {
    unsigned int count = this->row_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->row(i));
    }
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  {
    unsigned int count = this->args_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->args(i));
    }
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Insert::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Insert)
  GOOGLE_DCHECK_NE(&from, this);
  const Insert* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Insert>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Insert)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Insert)
    MergeFrom(*source);
  }
}

void Insert::MergeFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  projection_.MergeFrom(from.projection_);
  row_.MergeFrom(from.row_);
  args_.MergeFrom(from.args_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
  }
}

void Insert::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Insert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Insert::CopyFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->projection())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->row())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  return true;
}

void Insert::Swap(Insert* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Insert::InternalSwap(Insert* other) {
  projection_.UnsafeArenaSwap(&other->projection_);
  row_.UnsafeArenaSwap(&other->row_);
  args_.UnsafeArenaSwap(&other->args_);
  std::swap(collection_, other->collection_);
  std::swap(data_model_, other->data_model_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Insert::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[8];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Insert

// required .Mysqlx.Crud.Collection collection = 1;
bool Insert::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Insert::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
void Insert::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
void Insert::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
const ::Mysqlx::Crud::Collection& Insert::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
::Mysqlx::Crud::Collection* Insert::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.collection)
  return collection_;
}
::Mysqlx::Crud::Collection* Insert::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Insert.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
void Insert::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Insert.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
bool Insert::has_data_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Insert::set_has_data_model() {
  _has_bits_[0] |= 0x00000002u;
}
void Insert::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000002u;
}
void Insert::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
::Mysqlx::Crud::DataModel Insert::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
void Insert::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Insert.data_model)
}

// repeated .Mysqlx.Crud.Column projection = 3;
int Insert::projection_size() const {
  return projection_.size();
}
void Insert::clear_projection() {
  projection_.Clear();
}
const ::Mysqlx::Crud::Column& Insert::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.projection)
  return projection_.Get(index);
}
::Mysqlx::Crud::Column* Insert::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.projection)
  return projection_.Mutable(index);
}
::Mysqlx::Crud::Column* Insert::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.projection)
  return projection_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >*
Insert::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.projection)
  return &projection_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Column >&
Insert::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.projection)
  return projection_;
}

// repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
int Insert::row_size() const {
  return row_.size();
}
void Insert::clear_row() {
  row_.Clear();
}
const ::Mysqlx::Crud::Insert_TypedRow& Insert::row(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.row)
  return row_.Get(index);
}
::Mysqlx::Crud::Insert_TypedRow* Insert::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.row)
  return row_.Mutable(index);
}
::Mysqlx::Crud::Insert_TypedRow* Insert::add_row() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.row)
  return row_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
Insert::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.row)
  return &row_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
Insert::row() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.row)
  return row_;
}

// repeated .Mysqlx.Datatypes.Scalar args = 5;
int Insert::args_size() const {
  return args_.size();
}
void Insert::clear_args() {
  args_.Clear();
}
const ::Mysqlx::Datatypes::Scalar& Insert::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.args)
  return args_.Get(index);
}
::Mysqlx::Datatypes::Scalar* Insert::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.args)
  return args_.Mutable(index);
}
::Mysqlx::Datatypes::Scalar* Insert::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.args)
  return args_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Insert::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.args)
  return &args_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Insert::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.args)
  return args_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Update::kCollectionFieldNumber;
const int Update::kDataModelFieldNumber;
const int Update::kCriteriaFieldNumber;
const int Update::kArgsFieldNumber;
const int Update::kLimitFieldNumber;
const int Update::kOrderFieldNumber;
const int Update::kOperationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Update::Update()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Update)
}
Update::Update(const Update& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      args_(from.args_),
      order_(from.order_),
      operation_(from.operation_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Update)
}

void Update::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&collection_, 0, reinterpret_cast<char*>(&limit_) -
    reinterpret_cast<char*>(&collection_) + sizeof(limit_));
  data_model_ = 1;
}

Update::~Update() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Update)
  SharedDtor();
}

void Update::SharedDtor() {
  if (this != internal_default_instance()) {
    delete collection_;
  }
  if (this != internal_default_instance()) {
    delete criteria_;
  }
  if (this != internal_default_instance()) {
    delete limit_;
  }
}

void Update::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Update::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[9].descriptor;
}

const Update& Update::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Update* Update::New(::google::protobuf::Arena* arena) const {
  Update* n = new Update;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Update::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Update)
  args_.Clear();
  order_.Clear();
  operation_.Clear();
  if (_has_bits_[0 / 32] & 15u) {
    if (has_collection()) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->::Mysqlx::Crud::Collection::Clear();
    }
    if (has_criteria()) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->::Mysqlx::Crud::Limit::Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Update::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Update)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3: {
        if (tag == 24u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 4;
      case 4: {
        if (tag == 34u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 5;
      case 5: {
        if (tag == 42u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 6;
      case 6: {
        if (tag == 50u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
      case 7: {
        if (tag == 58u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_operation()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 8;
      case 8: {
        if (tag == 66u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Update)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Update)
  return false;
#undef DO_
}

void Update::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Update)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->collection_, output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->criteria_, output);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->limit_, output);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (unsigned int i = 0, n = this->order_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->order(i), output);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (unsigned int i = 0, n = this->operation_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->operation(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->args(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Update)
}

::google::protobuf::uint8* Update::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Update)
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->collection_, false, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (has_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->criteria_, false, target);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->limit_, false, target);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (unsigned int i = 0, n = this->order_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, this->order(i), false, target);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (unsigned int i = 0, n = this->operation_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->operation(i), false, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, this->args(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Update)
  return target;
}

size_t Update::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Update)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 2;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->collection_);
  }
  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  {
    unsigned int count = this->args_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->args(i));
    }
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  {
    unsigned int count = this->order_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->order(i));
    }
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  {
    unsigned int count = this->operation_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->operation(i));
    }
  }

  if (_has_bits_[0 / 32] & 14u) {
    // optional .Mysqlx.Expr.Expr criteria = 4;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 5;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->limit_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Update::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Update)
  GOOGLE_DCHECK_NE(&from, this);
  const Update* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Update>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Update)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Update)
    MergeFrom(*source);
  }
}

void Update::MergeFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Update)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  operation_.MergeFrom(from.operation_);
  if (from._has_bits_[0 / 32] & 15u) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
  }
}

void Update::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Update)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Update::CopyFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Update)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->operation())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  return true;
}

void Update::Swap(Update* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Update::InternalSwap(Update* other) {
  args_.UnsafeArenaSwap(&other->args_);
  order_.UnsafeArenaSwap(&other->order_);
  operation_.UnsafeArenaSwap(&other->operation_);
  std::swap(collection_, other->collection_);
  std::swap(criteria_, other->criteria_);
  std::swap(limit_, other->limit_);
  std::swap(data_model_, other->data_model_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Update::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[9];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Update

// required .Mysqlx.Crud.Collection collection = 2;
bool Update::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Update::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
void Update::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
void Update::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
const ::Mysqlx::Crud::Collection& Update::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
::Mysqlx::Crud::Collection* Update::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.collection)
  return collection_;
}
::Mysqlx::Crud::Collection* Update::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
void Update::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
bool Update::has_data_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Update::set_has_data_model() {
  _has_bits_[0] |= 0x00000008u;
}
void Update::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000008u;
}
void Update::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
::Mysqlx::Crud::DataModel Update::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
void Update::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Update.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 4;
bool Update::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Update::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
void Update::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
void Update::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
const ::Mysqlx::Expr::Expr& Update::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.criteria)
  return criteria_ != NULL ? *criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
::Mysqlx::Expr::Expr* Update::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.criteria)
  return criteria_;
}
::Mysqlx::Expr::Expr* Update::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
void Update::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 8;
int Update::args_size() const {
  return args_.size();
}
void Update::clear_args() {
  args_.Clear();
}
const ::Mysqlx::Datatypes::Scalar& Update::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.args)
  return args_.Get(index);
}
::Mysqlx::Datatypes::Scalar* Update::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.args)
  return args_.Mutable(index);
}
::Mysqlx::Datatypes::Scalar* Update::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.args)
  return args_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Update::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.args)
  return &args_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Update::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.args)
  return args_;
}

// optional .Mysqlx.Crud.Limit limit = 5;
bool Update::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Update::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
void Update::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
void Update::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
const ::Mysqlx::Crud::Limit& Update::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.limit)
  return limit_ != NULL ? *limit_
                         : *::Mysqlx::Crud::Limit::internal_default_instance();
}
::Mysqlx::Crud::Limit* Update::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    limit_ = new ::Mysqlx::Crud::Limit;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.limit)
  return limit_;
}
::Mysqlx::Crud::Limit* Update::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
void Update::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.limit)
}

// repeated .Mysqlx.Crud.Order order = 6;
int Update::order_size() const {
  return order_.size();
}
void Update::clear_order() {
  order_.Clear();
}
const ::Mysqlx::Crud::Order& Update::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.order)
  return order_.Get(index);
}
::Mysqlx::Crud::Order* Update::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.order)
  return order_.Mutable(index);
}
::Mysqlx::Crud::Order* Update::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.order)
  return order_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Update::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.order)
  return &order_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Update::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.order)
  return order_;
}

// repeated .Mysqlx.Crud.UpdateOperation operation = 7;
int Update::operation_size() const {
  return operation_.size();
}
void Update::clear_operation() {
  operation_.Clear();
}
const ::Mysqlx::Crud::UpdateOperation& Update::operation(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.operation)
  return operation_.Get(index);
}
::Mysqlx::Crud::UpdateOperation* Update::mutable_operation(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.operation)
  return operation_.Mutable(index);
}
::Mysqlx::Crud::UpdateOperation* Update::add_operation() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.operation)
  return operation_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
Update::mutable_operation() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.operation)
  return &operation_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
Update::operation() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.operation)
  return operation_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Delete::kCollectionFieldNumber;
const int Delete::kDataModelFieldNumber;
const int Delete::kCriteriaFieldNumber;
const int Delete::kArgsFieldNumber;
const int Delete::kLimitFieldNumber;
const int Delete::kOrderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Delete::Delete()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Delete)
}
Delete::Delete(const Delete& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      args_(from.args_),
      order_(from.order_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = NULL;
  }
  if (from.has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = NULL;
  }
  if (from.has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = NULL;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Delete)
}

void Delete::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&collection_, 0, reinterpret_cast<char*>(&limit_) -
    reinterpret_cast<char*>(&collection_) + sizeof(limit_));
  data_model_ = 1;
}

Delete::~Delete() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Delete)
  SharedDtor();
}

void Delete::SharedDtor() {
  if (this != internal_default_instance()) {
    delete collection_;
  }
  if (this != internal_default_instance()) {
    delete criteria_;
  }
  if (this != internal_default_instance()) {
    delete limit_;
  }
}

void Delete::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Delete::descriptor() {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[10].descriptor;
}

const Delete& Delete::default_instance() {
  protobuf_mysqlx_5fcrud_2eproto::InitDefaults();
  return *internal_default_instance();
}

Delete* Delete::New(::google::protobuf::Arena* arena) const {
  Delete* n = new Delete;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Delete::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Delete)
  args_.Clear();
  order_.Clear();
  if (_has_bits_[0 / 32] & 15u) {
    if (has_collection()) {
      GOOGLE_DCHECK(collection_ != NULL);
      collection_->::Mysqlx::Crud::Collection::Clear();
    }
    if (has_criteria()) {
      GOOGLE_DCHECK(criteria_ != NULL);
      criteria_->::Mysqlx::Expr::Expr::Clear();
    }
    if (has_limit()) {
      GOOGLE_DCHECK(limit_ != NULL);
      limit_->::Mysqlx::Crud::Limit::Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Delete::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Mysqlx.Crud.Delete)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collection()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2: {
        if (tag == 16u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Mysqlx::Crud::DataModel_IsValid(value)) {
            set_data_model(static_cast< ::Mysqlx::Crud::DataModel >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Expr.Expr criteria = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_criteria()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Mysqlx.Crud.Limit limit = 4;
      case 4: {
        if (tag == 34u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Mysqlx.Crud.Order order = 5;
      case 5: {
        if (tag == 42u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_order()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .Mysqlx.Datatypes.Scalar args = 6;
      case 6: {
        if (tag == 50u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_args()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Mysqlx.Crud.Delete)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Mysqlx.Crud.Delete)
  return false;
#undef DO_
}

void Delete::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Mysqlx.Crud.Delete)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->collection_, output);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_model(), output);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (has_criteria()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->criteria_, output);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->limit_, output);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (unsigned int i = 0, n = this->order_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->order(i), output);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->args(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Mysqlx.Crud.Delete)
}

::google::protobuf::uint8* Delete::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Delete)
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->collection_, false, target);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (has_data_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (has_criteria()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->criteria_, false, target);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->limit_, false, target);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (unsigned int i = 0, n = this->order_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->order(i), false, target);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (unsigned int i = 0, n = this->args_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, this->args(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Delete)
  return target;
}

size_t Delete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Delete)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .Mysqlx.Crud.Collection collection = 1;
  if (has_collection()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->collection_);
  }
  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  {
    unsigned int count = this->args_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->args(i));
    }
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  {
    unsigned int count = this->order_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->order(i));
    }
  }

  if (_has_bits_[0 / 32] & 14u) {
    // optional .Mysqlx.Expr.Expr criteria = 3;
    if (has_criteria()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 4;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->limit_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (has_data_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_model());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Delete::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Mysqlx.Crud.Delete)
  GOOGLE_DCHECK_NE(&from, this);
  const Delete* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Delete>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Mysqlx.Crud.Delete)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Mysqlx.Crud.Delete)
    MergeFrom(*source);
  }
}

void Delete::MergeFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Delete)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  args_.MergeFrom(from.args_);
  order_.MergeFrom(from.order_);
  if (from._has_bits_[0 / 32] & 15u) {
    if (from.has_collection()) {
      mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from.collection());
    }
    if (from.has_criteria()) {
      mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from.criteria());
    }
    if (from.has_limit()) {
      mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from.limit());
    }
    if (from.has_data_model()) {
      set_data_model(from.data_model());
    }
  }
}

void Delete::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Mysqlx.Crud.Delete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Delete::CopyFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Delete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Delete::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->args())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->order())) return false;
  if (has_collection()) {
    if (!this->collection_->IsInitialized()) return false;
  }
  if (has_criteria()) {
    if (!this->criteria_->IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit_->IsInitialized()) return false;
  }
  return true;
}

void Delete::Swap(Delete* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Delete::InternalSwap(Delete* other) {
  args_.UnsafeArenaSwap(&other->args_);
  order_.UnsafeArenaSwap(&other->order_);
  std::swap(collection_, other->collection_);
  std::swap(criteria_, other->criteria_);
  std::swap(limit_, other->limit_);
  std::swap(data_model_, other->data_model_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Delete::GetMetadata() const {
  protobuf_mysqlx_5fcrud_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_mysqlx_5fcrud_2eproto::file_level_metadata[10];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Delete

// required .Mysqlx.Crud.Collection collection = 1;
bool Delete::has_collection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Delete::set_has_collection() {
  _has_bits_[0] |= 0x00000001u;
}
void Delete::clear_has_collection() {
  _has_bits_[0] &= ~0x00000001u;
}
void Delete::clear_collection() {
  if (collection_ != NULL) collection_->::Mysqlx::Crud::Collection::Clear();
  clear_has_collection();
}
const ::Mysqlx::Crud::Collection& Delete::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.collection)
  return collection_ != NULL ? *collection_
                         : *::Mysqlx::Crud::Collection::internal_default_instance();
}
::Mysqlx::Crud::Collection* Delete::mutable_collection() {
  set_has_collection();
  if (collection_ == NULL) {
    collection_ = new ::Mysqlx::Crud::Collection;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.collection)
  return collection_;
}
::Mysqlx::Crud::Collection* Delete::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.collection)
  clear_has_collection();
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = NULL;
  return temp;
}
void Delete::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  delete collection_;
  collection_ = collection;
  if (collection) {
    set_has_collection();
  } else {
    clear_has_collection();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
bool Delete::has_data_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Delete::set_has_data_model() {
  _has_bits_[0] |= 0x00000008u;
}
void Delete::clear_has_data_model() {
  _has_bits_[0] &= ~0x00000008u;
}
void Delete::clear_data_model() {
  data_model_ = 1;
  clear_has_data_model();
}
::Mysqlx::Crud::DataModel Delete::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.data_model)
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
void Delete::set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  set_has_data_model();
  data_model_ = value;
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Delete.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 3;
bool Delete::has_criteria() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Delete::set_has_criteria() {
  _has_bits_[0] |= 0x00000002u;
}
void Delete::clear_has_criteria() {
  _has_bits_[0] &= ~0x00000002u;
}
void Delete::clear_criteria() {
  if (criteria_ != NULL) criteria_->::Mysqlx::Expr::Expr::Clear();
  clear_has_criteria();
}
const ::Mysqlx::Expr::Expr& Delete::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.criteria)
  return criteria_ != NULL ? *criteria_
                         : *::Mysqlx::Expr::Expr::internal_default_instance();
}
::Mysqlx::Expr::Expr* Delete::mutable_criteria() {
  set_has_criteria();
  if (criteria_ == NULL) {
    criteria_ = new ::Mysqlx::Expr::Expr;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.criteria)
  return criteria_;
}
::Mysqlx::Expr::Expr* Delete::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.criteria)
  clear_has_criteria();
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = NULL;
  return temp;
}
void Delete::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  delete criteria_;
  criteria_ = criteria;
  if (criteria) {
    set_has_criteria();
  } else {
    clear_has_criteria();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 6;
int Delete::args_size() const {
  return args_.size();
}
void Delete::clear_args() {
  args_.Clear();
}
const ::Mysqlx::Datatypes::Scalar& Delete::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.args)
  return args_.Get(index);
}
::Mysqlx::Datatypes::Scalar* Delete::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.args)
  return args_.Mutable(index);
}
::Mysqlx::Datatypes::Scalar* Delete::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.args)
  return args_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Delete::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.args)
  return &args_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Delete::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.args)
  return args_;
}

// optional .Mysqlx.Crud.Limit limit = 4;
bool Delete::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Delete::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
void Delete::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
void Delete::clear_limit() {
  if (limit_ != NULL) limit_->::Mysqlx::Crud::Limit::Clear();
  clear_has_limit();
}
const ::Mysqlx::Crud::Limit& Delete::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.limit)
  return limit_ != NULL ? *limit_
                         : *::Mysqlx::Crud::Limit::internal_default_instance();
}
::Mysqlx::Crud::Limit* Delete::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    limit_ = new ::Mysqlx::Crud::Limit;
  }
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.limit)
  return limit_;
}
::Mysqlx::Crud::Limit* Delete::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.limit)
  clear_has_limit();
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
void Delete::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    set_has_limit();
  } else {
    clear_has_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.limit)
}

// repeated .Mysqlx.Crud.Order order = 5;
int Delete::order_size() const {
  return order_.size();
}
void Delete::clear_order() {
  order_.Clear();
}
const ::Mysqlx::Crud::Order& Delete::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.order)
  return order_.Get(index);
}
::Mysqlx::Crud::Order* Delete::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.order)
  return order_.Mutable(index);
}
::Mysqlx::Crud::Order* Delete::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.order)
  return order_.Add();
}
::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Delete::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.order)
  return &order_;
}
const ::google::protobuf::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Delete::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.order)
  return order_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Crud
}  // namespace Mysqlx

// @@protoc_insertion_point(global_scope)
